<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RxJS学习总结-创建操作符]]></title>
    <url>%2F2019%2F02%2F25%2FRxJS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[上一篇博客总结了一下Observable可观察对象，主要使用了new Observable(subscriber)来创建Observable流。但这种数据流的创建方式，一是比较繁琐，需要自己去定义发出值，错误处理等，不够简洁；二是一旦繁杂起来，手写subscriber极容易出错。RxJS中就抽出了若干固定模式，称为创建类操作符，方便我们来使用。 创建类操作符是数据流的源头，大部分（并不是全部）都是静态操作符。按照同步/异步，可以分为创建同步数据流和异步数据流。 创建同步数据流创建同步的Observable对象，需要关心产生了什么数据，数据之间的先后顺序如何，不需要关心时间。 of 列举数据of&lt;T&gt;(...args: Array&lt;T | SchedulerLike&gt;): Observable&lt;T&gt; of操作符是将参数转化为Observable对象的序列。这是最简单的一个创建操作符。 123456789101112import &#123; of &#125; from 'rxjs';of(1,3,4,5).subscribe( val =&gt; console.log('next:' + val), err =&gt; console.log('error:' + err), () =&gt; console.log('complete'));// next:1// next:3// next:4// next:5// complete 数据发送完，会调用complete()函数。注意，of发出的数据是同步发出的，只有先后顺序，没有时间间隔。 range 指定范围range(start: number = 0, count?: number, scheduler?: SchedulerLike): Observable&lt;number&gt; range操作符用来产生一个范围内的正整数序列。接收的第一个参数是number类型，表示起始值，第二个参数是发出的数据个数，每个数据间隔为1。如果只传入一个参数，则默认起始数字为0。 1234567891011121314151617181920import &#123; of, range &#125; from 'rxjs'; range(2, 3).subscribe( val =&gt; console.log('next:' + val), err =&gt; console.log('error:' + err), () =&gt; console.log('complete'));// next:2// next:3// next:4// completerange(2).subscribe( val =&gt; console.log('next:' + val), err =&gt; console.log('error:' + err), () =&gt; console.log('complete'));// next:0// next:1// complete generate 循环创建generate&lt;T, S&gt;(initialStateOrOptions: S | GenerateOptions&lt;T, S&gt;, condition?: ConditionFunc&lt;S&gt;, iterate?: IterateFunc&lt;S&gt;, resultSelectorOrObservable?: (ResultFunc&lt;S, T&gt;) | SchedulerLike, scheduler?: SchedulerLike): Observable&lt;T&gt; generate操作符类似一个for循环，设定一个初始值，每次递增这个值，直到满足某个条件的时候才终止循环，同时，循环体内可以根据当前值产生数据。如果我们需要使用for循环产生一组数据，那么就适合使用generate操作符。 empty 立即完成empty(scheduler?: SchedulerLike) empty操作符用来产生一个立即完结的Observable对象，不产生任何数据，直接complete。 12345678import &#123; empty &#125; from 'rxjs'; empty().subscribe( val =&gt; console.log('next:' + val), err =&gt; console.log('error:' + err), () =&gt; console.log('complete'))// complete never 永不完成never() never操作符永远不会完结，即不产生数据，也不产生错误。 12345678import &#123; never &#125; from 'rxjs'; never().subscribe( val =&gt; console.log('next:' + val), err =&gt; console.log('error:' + err), () =&gt; console.log('complete'))// 什么也没有 throwError 扔出错误throwError(error: any, scheduler?: SchedulerLike): Observable&lt;never&gt; throw操作符一开始就直接抛出错误，不会产生任何数据。 12345678import &#123; throwError &#125; from 'rxjs'; throwError('Oop!').subscribe( val =&gt; console.log('next:' + val), err =&gt; console.log('error:' + err), () =&gt; console.log('complete'))// error:Oop! 创建异步数据流创建异步的Observable对象，重点需要关心产生数据之间的时间间隔。 fromform&lt;T&gt;(input: ObservableInput&lt;T&gt;, scheduler?: SchedulerLike): Observable&lt;T&gt; from操作符接收数组、类数组对象、Promise、iterable object或者Observable-like object来创建一个Observable对象。 123456789101112131415161718192021222324252627282930313233343536import &#123; from &#125; from 'rxjs'; //数组from([1, 2, 3]).subscribe( val =&gt; console.log('next:' + val), err =&gt; console.log('error:' + err), () =&gt; console.log('complete'))// next:1// next:2// next:3// complete//字符串from('abc').subscribe( val =&gt; console.log('next:' + val), err =&gt; console.log('error:' + err), () =&gt; console.log('complete'))// next:a// next:b// next:c// complete//promisefrom(new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('Hello RxJS!'); &#125;,3000)&#125;)).subscribe( val =&gt; console.log('next:' + val), err =&gt; console.log('error:' + err), () =&gt; console.log('complete'))// next:Hello RxJS!// complete fromEventfromEvent&lt;T&gt;(target: FromEventTarget&lt;T&gt;, eventName: string, options?: EventListenerOptions | ((...args: any[]) =&gt; T), resultSelector?: ((...args: any[]) =&gt; T)): Observable&lt;T&gt; formEvent经常被用来将页面中的DOM事件转化为Observable对象中的数据，是连接DOM和RxJS的桥梁，产生Observable对象之后，就可以交由RxJS来进行后续的处理。 12345678import &#123; from &#125; from 'rxjs'; fromEvent(document, 'click').subscribe( val =&gt; console.log('next:' + val), err =&gt; console.log('error:' + err), () =&gt; console.log('complete'))// 点击页面，打印 next:[object MouseEvent]，发出一个点击事件流 interval 定时产生数据interval(period: 0 = 0, scheduler: SchedulerLike = async): Observable&lt;number&gt; interval接收一个数值类型的参数，代表产生数据的间隔毫秒数，返回从0开始，按这个间隔递增的整数Observable序列。是一个无限序列。 1234567891011121314import &#123; interval &#125; from 'rxjs'; interval(1000).subscribe( val =&gt; console.log('next:' + val), err =&gt; console.log('error:' + err), () =&gt; console.log('complete'))// ...1000ms// next:0// ...1000ms// next:1// ...1000ms// next:2// ... timer 定时产生数据timer(dueTime: number | Date = 0, periodOrScheduler?: number | SchedulerLike, scheduler?: SchedulerLike): Observable&lt;number&gt; timer第一个参数可以是毫秒数值，或者一个Date类型的对象，在经过这个毫秒或者到达这个Date时间过发出0后结束。如果传入第二个参数，则会产生一个持续发出递增数据的Observable对象，类似于interval操作符。 1234567891011121314import &#123; timer &#125; from 'rxjs'; timer(1000, 2000).subscribe( val =&gt; console.log('next:' + val), err =&gt; console.log('error:' + err), () =&gt; console.log('complete'))// ...1000ms// next:0// ...2000ms// next:1// ...2000ms// next:2// ... 可以简单推出，timer(1000, 1000)相当于interval(1000)。 repeat 重复订阅repeat&lt;T&gt;(count: number = -1): MonoTypeOperatorFunction&lt;T&gt; repeat从它的功能上来讲是可以看做创建类操作符的。但是它并不是一个静态方法（相比于上面的操作符），它是Observable的实例方法。repeat承接的是上游的数据流，通过退订-&gt;重新订阅的方法向下游发出数据。repeat只有等到上游Observable对象完结之后才会重新订阅，上游不完结，永远不会重新订阅。订阅次数是传入的参数次数。 12345678910111213import &#123; timer &#125; from 'rxjs'; import &#123; repeat &#125; from 'rxjs/operators';of(1).pipe( repeat(2)).subscribe( val =&gt; console.log('next:' + val), err =&gt; console.log('error:' + err), () =&gt; console.log('complete'))// next:1// next:1// complete 注意，repeat相当于将上游的流重复了count次发了出去，observer订阅到的流只是这count次的流。 repeatWhen 有条件的重复订阅repeatWhen&lt;T&gt;(notifier: (notifications: Observable&lt;any&gt;) =&gt; Observable&lt;any&gt;): MonoTypeOperatorFunction&lt;T&gt; repeatWhen接收一个函数notifier作为参数，这个函数在上游第一次产生异常的时候调用，然后这个函数应该返回一个Observable对象，当这个Observable发出一个数据的时候，repeatWhen就会退订上游并重新订阅。 1234567891011121314151617181920import &#123; of, timer &#125; from 'rxjs'; import &#123; repeatWhen &#125; from 'rxjs/operators';of(1, 2, 3).pipe( repeatWhen(() =&gt; &#123; timer(2000) &#125;)).subscribe( val =&gt; console.log('next:' + val), err =&gt; console.log('error:' + err), () =&gt; console.log('complete'))// next:1// next:2// next:3// 等待2s// next:1// next:2// next:3// complete 如果上游产生的是异步数据，不知道什么时候结束，那么什么重复就比较难判断。这时候可以为notifier函数传入一个参数notifications，是一个Observable对象，当上游完成的时候，notifications就会发出一个数据。 12345678910111213141516171819202122232425import &#123; interval &#125; from 'rxjs'; import &#123; repeatWhen, take &#125; from 'rxjs/operators';interval(1000).pipe( take(3), repeatWhen((notification) =&gt; &#123; return notification.pipe(delay(3000)) &#125;)).subscribe( val =&gt; console.log('next:' + val), err =&gt; console.log('error:' + err), () =&gt; console.log('complete'))// next:0// next:1// next:2// 等待3s// next:0// next:1// next:2// 等待3s// next:0// next:1// next:2// ... 以上就是RxJS中最常用的几个创建操作符。还有几个操作符如ajax、defer等用的比较少，用到的时候查文档即可。不过写到这里感觉这个系列博客如果只是重复机械式的把几十个操作符列举一遍实在没有任何意义，总结的再详细也只是官方文档的搬运工，而且也不会比官方例子更详实。所以接下来会简要概括，将操作符进行分类，方便记忆和日后查阅时能找准方向。最后会将重点放在Subject和Scheduler的理解上。]]></content>
      <tags>
        <tag>知识积累</tag>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJS学习总结-Observable]]></title>
    <url>%2F2019%2F02%2F22%2FRxJS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-Observable%2F</url>
    <content type="text"><![CDATA[上篇博客我们使用RxJS的一些知识实现了一个贪吃蛇的小游戏，对RxJS有了一定的了解。接下来几篇博客会从基础开始，总结一下RxJS的概念、操作符、多播、调度器等知识点。 今天先来看一下Observable的几个相关概念。 Observable可观察对象概述什么是Observable？讲道理我也不太清楚到底什么是Observable，硬要一个定义的话，可以说Observable是一个以推送Push方式产生一个或多个值（同步或者异步）的集合。我们以推送方式和产生值的数量来对JavaScript常见的几种概念来个分类： 单值SINGLE 多值MULTIPLE 拉取PULL Function Iterator 推送PUSH Promise Observable Function函数，每个函数只能有一个return出来的值，而且当调用它时，会同步的发出值。生产者foo()的值是由消费者x主动Pull拉取来的，单值。 123456789function foo() &#123; console.log('hello'); return 47; return 48; //被忽略&#125;const x = foo.call(); // 或者foo();console.log(x);// hello// 47 Iterator迭代器，迭代器可以产生多个值，需要消费者自己Pull取用。想想async/await。 1234567891011const arr = [1, 2, 3];const iterator = arr[Symbol.iterator]();iterator.next();// &#123; value: 1, done: false &#125;iterator.next();// &#123; value: 2, done: false &#125;iterator.next();// &#123; value: 3, done: false &#125;iterator.next();// &#123; value: undefined, done: true &#125; Promise承诺(感觉怪怪的)，承诺以推送Push的方式发出（或者不发出）单值。承诺在创建的时候会立即计算出结果，而且只执行一次（跟Observable的区别）。 1234567const promise = new Promise((resolve, reject) =&gt; &#123; console.log('hello'); resolve('world');&#125;)// hellopromise.then(res =&gt; console.log(res));// world Observable可观察对象，今天的重点，以推送Push的方式同步或异步的发出一个或多个值，直接看代码： 123456789101112import &#123; Observable &#125; from 'rxjs';const observable = new Observable(subscriber =&gt; &#123; console.log('hello'); // 不订阅，不会打印 subscriber.next(1); subscriber.next(2); setTimeout(() =&gt; &#123; subscriber.next(3); // 订阅后 1s 发出 3 subscriber.complete(); &#125;, 1000);&#125;)// 创建后不会有任何值打印出来 想要调用observable并且看到值，我们需要订阅subscribe它： 1234567891011121314console.log('just before subscribe');observable.subscribe(&#123; next(x) &#123; console.log('got value ' + x); &#125;, error(err) &#123; console.error('something wrong occurred: ' + err); &#125;, complete() &#123; console.log('done'); &#125;&#125;);console.log('just after subscribe');// just before subscribe// hello// got value 1// got value 2// just after subscribe// got value 3// done Pull &amp;&amp; PushPull拉取模式，消费者Consumer决定什么时候从生产者Producer处拿值。生产者不知道数据什么时候会发给消费者。如上面的Function和Iterator，只有当函数foo()调用或者变量iterator调用next()方法时，即“拉取Pull”时，才会“消费”值。 Push推送模式，生产者Producer决定什么时候发出值，消费者不知道数据什么时候过来。Promise是最常见的推送模式，promise推送resolved值到回调函数。RxJS的Observable也是推送模式，不过它可以推送多个值（同步或异步）。 Observable &amp; Function &amp; EventEmitters &amp; Promise 异同Observable有点像无参数的函数Function，但是是可以产生多个值。先看下面： 1234567891011121314151617181920212223// Function 形式function foo() &#123; console.log('hello'); return 47;&#125;const x = foo.call();console.log(x); // hello 47const y = foo.call();console.log(x); // hello 47// Observable 形式import &#123; Observable &#125; from 'rxjs';const foo = new Observable(subscriber =&gt; &#123; console.log('hello'); subscriber.next(47);&#125;); foo.subscribe(x =&gt; &#123; console.log(x); // hello 47&#125;);foo.subscribe(y =&gt; &#123; console.log(y); // hello 47&#125;); Function和Observable都是延迟计算lazy computation，如果你不调用函数foo()，那么console.log(&#39;hello&#39;)就不会运行；同样，如果你不订阅（使用subscribe）Observable，那么console.log(&#39;hello&#39;)也不会运行。而且不管调用还是订阅都是一个独立的操作：多次调用或者多次订阅的副作用side effects是相互独立，互不影响的。 Observable和EventEmitter有些类似，但Observable适用范围更广，且数据在交付前可以预处理： 123456789101112131415// EventEmitterfunction handler(e) &#123; // 数据无法被预处理 console.log('Clicked', e);&#125;button.addEventListener('click', handler);button.removeEventListener('click', handler);// Observablelet clicks$ = fromEvent(buttonEl, 'click');let subscription = clicks$.pipe( map(e =&gt; e.target.value) // 预处理事件，直接发出value).subscribe(val =&gt; console.log('Clicked', val))subscription.unsubscribe();// 除事件处理外，Observable还可以处理其他数据流 这里，EventEmitter更像是使用了Subject的Observable，后面会再讨论Subject。 Observable经常被拿来跟Promise进行比较。有一些关键点的不同： Observable是声明式的，在被订阅之前，它不会开始执行。Promise是在创建时就立即执行的，具体见上面的例子。 Observable可以提供多个值，Promise只提供一个。Observable可以随着时间的推移获取多个值（流）。 Observable可以通过管道pipe()串联处理数据，Promise()只有then()语句。Observable可以使得数据在被订阅之前进行处理。 Observable的subscribe(observer)会负责处理错误error，Promise会把错误推给它的子Promise去处理。 最重要一点，Observable是可以通过unsubscribe()取消的。取消订阅就会移除监听器，不再接收将来的值。 最后简单提一下Observable和数组Array在运算方式上的不同。先看下面： 123456789101112// 数组链式调用let arr = [1, 2, 3, 4];let result = arr.map(num =&gt; num * num).filter(num =&gt; num &gt; 5);console.log(result); // [9, 16]// Observable管道操作import &#123; from &#125; from 'rxjs';import &#123; map, filter &#125; from 'rxjs/operators';from([1, 2, 3, 4]).pipe( map(num =&gt; num * num), filter(num =&gt; num &gt; 5)).subscribe(console.log); // 9, 16 数组的链式调用，每一步都会等所有数据计算完，才继续走下一步。即.map()先返回一个数据[1, 4, 9, 16]，然后.filter()过滤后，返回[9, 16]；而Observable的管道，每一个值都会处理到底，再继续下一个值。即数字1先.map()，再.filter()，不符合；同样，2不符合；数字3进来，符合，打印出9；最后处理数字4，打印16。 subscriber订阅者函数当我们手动创建一个Observable的实例时，就需要传入一个订阅者函数subscriber。当有消费者调用subscribe()方法时，这个函数就会执行。 123456789101112import &#123; Observable &#125; from 'rxjs';const observable = new Observable(function subscriber(subscriber) &#123; try &#123; subscriber.next(1); subscriber.next(2); subscriber.next(3); subscriber.complete(); // 完成 subscriber.next(4); // 不会发出 &#125; catch (err) &#123; subscriber.error(err); // 捕获错误 &#125;&#125;) 不过，我们一般情况下不使用这种形式创建Observable，而是使用creation functions，如of()、fromEvent()、interval()等等。 Observables can be created with new Observable. Most commonly, observables are created using creation functions, like of, from, interval, etc. 注意，complete()后，后面的值将不会再发出。自定义subscriber函数时，最好将代码用try/catch包裹，处理错误。 订阅Subscribing只有当有人订阅 Observable 的实例时，它才会开始发布值。 订阅时要先调用该实例的 subscribe() 方法，并把一个观察者对象observer传给它，用来接收通知。observer定义了收到数据时的处理器handler。同时subscribe()的调用会返回一个Subscription对象，这个对象有一个unsubscribe()方法，用来取消订阅。 1234567891011121314151617181920212223242526import &#123; Observable &#125; from 'rxjs';const observable = new Observable(subscriber =&gt; &#123; subscriber.next(1); subscriber.next(2); subscriber.next(3); subscriber.complete();&#125;);// 观察者对象const observer = &#123; next: x =&gt; console.log('next value: ' + x), error: err =&gt; console.error('error: ' + err), complete: () =&gt; console.log('complete'),&#125;// 第一次订阅observable.subscribe(observer);// next value: 1// next value: 2// next value: 3// complete// 第二次订阅observable.subscribe(observer);// next value: 1// next value: 2// next value: 3// complete 订阅后，Observable发出值，observer接收值，处理值。注意：多次订阅互不影响。 Subscribing to an Observable is like calling a function, providing callbacks where the data will be delivered to. 另外，订阅时还可以直接传入回调函数，next 处理器都是必要的，而 error 和 complete 处理器是可选的，注意传入顺序。 123456789observable.subscribe( x =&gt; console.log('next value: ' + x), err =&gt; console.error('error: ' + err), () =&gt; console.log('complete'));// next value: 1// next value: 2// next value: 3// complete 每当调用subscribe()方法时，都会返回一个Subscription对象，这个对象有一个unsubscribe()方法，用来取消订阅。类似于setInterval()和setTimeout()返回id的形式。 123const subscription = observable.subscribe(observer);// 之后取消订阅subscription.unsubscribe(); observer观察者观察者对象observer定义了一些回调函数来处理可观察对象Observable可能发来的三种通知： 通知类型 说明 next 必要。用来处理每个送达值。在开始执行后可能执行零次或多次。 error 可选。用来处理错误通知。错误会中断这个可观察对象实例的执行过程。 complete 可选。用来处理执行完毕（complete）通知。当执行完毕后，这些值就会继续传给下一个处理器。 以上就是Observable的一些基础知识点，简单记忆就是： 12const subscription = new Observable(subscriber).subscribe(observer);subscription.unsubscribe(); 接下来我们会先总结一下Observable的创建函数和操作符，RxJS繁琐就在于creation function和operators特别多，需要费点时间去记忆和理解，但也正因为这样，RxJS在处理流数据的时候才能“因材施教”，得心应手。过完这些知识点后，我们再去总结Subject和Scheduler这两个难搞的点。]]></content>
      <tags>
        <tag>知识积累</tag>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用RxJS实现一个贪吃蛇小游戏]]></title>
    <url>%2F2019%2F02%2F18%2F%E4%BD%BF%E7%94%A8RxJS%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%AA%E5%90%83%E8%9B%87%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[最近几周趁年底年初工作事情少，把RxJS的基础知识学习了一下，算是简单入了个门，近期准备写几篇博客总结一下RxJS的相关知识点，给自己找点事情做。 概述什么是RxJS？简单来说RxJS是响应式编程技术的JavaScript实现。响应式编程Reactive Extension，也叫ReactiveX，简称Rx，用官网上的一句话解释就是： An API for asynchronous programming with observable streams 其中，Observable是一种模式，有点像Observer Pattern观察者模式和Iterator Pattern迭代器模式的结合，而streams指的是数据流。Rx最早的实现是Rx.NET，之后又陆陆续续有了RxJava、RxPy等语言的实现。那RxJS当然就是Rx的JavaScript实现了。 不过今天先不细说RxJS的一些具体细节，这两天在网上找到一篇比较有趣的博客：使用RxJS来简单实现一个“贪吃蛇”小游戏，感觉很有趣，就由此作为RxJS入门学习的引子，看看如何用RxJS的思维方式去思考这个游戏的实现。先看一下游戏运行的预览图： 设计&amp;思考首先可以确定的是整个游戏界面都是使用canvas来进行绘制的，游戏中的“蛇”、“苹果”(红色块儿)和分数(动图未展示)都是canvas用进来的数据流streams来进行绘制的，而这些流的产生及走向就是我们要思考的。在响应式编程中，编程无外乎数据流及输入数据流。从概念上来说，当响应式编程执行时，它会建立一套可观察的管道，可以根据变化采取行动。我们需要理清数据源头，找到它，生成它，进而处理整合它。先来概览一下这个游戏的“流”： 我们反向来进行思考。首先，canvas绘制的数据流来自于scene$流，这个流是由snake$蛇、apples$苹果和score$分数三个流合成的，但其中apples$流又来源于snake$。其次，snake$流受到键盘的操作输入direction$、蛇本身的速度ticks$和蛇长度snakeLength$的影响，这三者构成了snake$流的数据。再看score$分数流，每当蛇的长度改变时，score$就会改变，发出数据；最后，当我们判断到蛇吃到了苹果，apples$流就会发出数据，同时通过appleEaten$使length$执行length$.next(point)，让蛇长度snakeLength$进行改变，进而触发一系列的数据发出。 仔细看，里面的源头只有direction$键盘方向事件、snakeLength$和ticks$定时器三个流。 实际操作canvas游戏布局这部分主要涉及到使canvas绘制一个游戏区域，细节略过，简单贴一下代码，博客最后有超链接指向源博客，有详细的说明。 12345678910111213141516171819// html// &lt;div id="snake"&gt;&lt;/div&gt;const COLS = 30;const ROWS = 30;const GAP_SIZE = 1;const CELL_SIZE = 10;const CANVAS_WIDTH = COLS * (CELL_SIZE + GAP_SIZE);const CANVAS_HEIGHT = ROWS * (CELL_SIZE + GAP_SIZE);function createCanvasElement() &#123; const canvas = document.createElement('canvas'); canvas.width = CANVAS_WIDTH; canvas.height = CANVAS_HEIGHT; return canvas;&#125;const canvas = createCanvasElement();let ctx = canvas.getContext('2d');document.getElementById('snake').appendChild(canvas); 键盘事件direction$流RxJS提供了一个fromEvent()操作符用来将事件转换为数据流，我们就用它来将玩家按键输入转为流数据，同时使用一些map()、filter()等操作符，来处理一下，确保只输出上下左右按键的值： 12345678910111213141516171819202122import &#123; fromEvent &#125; from 'rxjs';import &#123; map, filter &#125; from 'rxjs/operators';interface Point2D &#123; x: number; y: number;&#125;interface Directions &#123; [key: number]: Point2D;&#125;const DIRECTIONS: Directions = &#123; 37: &#123; x: -1, y: 0 &#125;, 39: &#123; x: 1, y: 0 &#125;, 38: &#123; x: 0, y: -1 &#125;, 40: &#123; x: 0, y: 1 &#125;&#125;;let keydown$ = fromEvent(document, 'keydown');let direction$ = keydown$.pipe( map((event: KeyboardEvent) =&gt; DIRECTIONS[event.keyCode]), filter(direction =&gt; !!direction),)// 临时订阅一下direction$，简单在console里看下效果direction$.subscribe(console.log); 页面中现在什么也没有，随便点按键盘按键，上下左右会输出值，其他键的输入会被忽略： 这里有个问题，我们的蛇是不能进行反方向运动的，所以我们需要忽略掉反向的输入；同时对于连续相同方向的输入，我们也应该忽略掉。这样的话我们就需要记录下键盘最后的输入状态，不过这里最好还是不要引入外部变量，全部交由Observable管道去处理，这里就要用到scan操作符，类似于js中的reduce()方法。同时对于相同方向的输入，我们使用distinctUntilChangede()来处理： 12345678910111213function nextDirection(previous, next) &#123; let isOpposite = (previous: Point2D, next: Point2D) =&gt; &#123; return next.x === previous.x * -1 || next.y === previous.y * -1; &#125;; return isOpposite(previous, next) ? previous : next;&#125;let direction$ = keydown$.pipe( map((event: KeyboardEvent) =&gt; DIRECTIONS[event.keyCode]), filter(direction =&gt; !!direction), startWith(INITIAL_DIRECTION), // 这里给direction$一个初始方向值 scan(nextDirection), // 使用处理函数处理方向流 distinctUntilChanged() // 当本次发出的数据跟前一个不同时，才会发出这个值) 这次，相同方向或者相反方向的输入都已经被处理（忽略）掉了。看一下direction$的Marbles图： snakeLength$蛇长流我们再回头看一下上面的snake流图，snakeLength$记录的是蛇当前的长度，发出的是蛇的长度的数字流。这个流基于（或者说来源于）length$流，length$记录的是蛇每次吃到苹果时增加的长度（也是增加的分数），这时候我们需要手动把值emit出去，使用BehaviorSubject()来实现。当length$发出值，即使用length$.next()来给Subject()提供值，这个值就会在snakeLength$上发出。我们需要snakeLength$的值累加上length$的值： 123456const SNAKE_LENGTH = 5;let length$ = new BehaviorSubject&lt;number&gt;(SNAKE_LENGTH); // SNAKE_LENGTH为蛇长的初始值let snakeLength$ = length$.pipe( scan((snakeLength, step) =&gt; snakeLength + step), share()); 注意，这里使用share()来允许多次订阅Observable，否则每次订阅都会重新创建源Observable。我们的snakeLength$同时被snake$流和score$流订阅，需要确保这两个流的获取的数据是同步的。 snake$流到目前，direction$和snakeLength$都已确定，还差一个ticks$就可以组成snake$流。ticks$是一个类计时器的东西，限定蛇的移动速度，抽象来讲就是我们需要一个按时间规律发出值的Observable，interval()操作符可以完成这个任务： 12const SPEED = 120;let ticks$ = interval(SPEED); // 每隔120ms依次发出...0...1...2... 从ticks$到最终的snake$，我们需要继续思考：每当ticks发出值，蛇继续前进还是增加身长，取决于是否吃到了苹果，我们可以使用scan()操作符去积累蛇身的长度。但接下来如何组合direction$、snakeLength$和ticks$？ withLatestFrom()可以完美实现我们的需求，我这里直接贴上官方文档的英文释义，通俗易懂： Combines the source Observable with other Observables to create an Observable whose values are calculated from the latest values of each, only when the source emits. withLatestFrom()组合多个Observables，并且具有主从关系，非常适合这里当蛇移动的时候去组合direction$和snakeLength$： 12345678910111213141516171819202122232425262728293031323334import &#123; move, generateSnake &#125; from './utils';let snake$ = ticks$.pipe( withLatestFrom(direction$, snakeLength$, (_, direction, snakeLength) =&gt; [direction,snakeLength]), scan(move, generateSnake()), // 根据方向流和蛇身长流来产生蛇流，最终发出[&#123;x: 1, y: 2&#125;, ...]数组对象形式的蛇流 share() // snake$被scene$和apples$使用，需要保持一致性，使用Subject()多播);// utils.ts// 处理数据，积累蛇身的数组export function move(snake, [direction, snakeLength]) &#123; let nx = snake[0].x; let ny = snake[0].y; nx += 1 * direction.x; ny += 1 * direction.y; let tail; if (snakeLength &gt; snake.length) &#123; tail = &#123; x: nx, y: ny &#125;; &#125; else &#123; tail = snake.pop(); tail.x = nx; tail.y = ny; &#125; snake.unshift(tail); return snake;&#125;// 生成初始蛇数据，数组对象形式export function generateSnake() &#123; let snake: Array&lt;Point2D&gt; = []; for (let i = SNAKE_LENGTH - 1; i &gt;= 0; i--) &#123; snake.push(&#123; x: i, y: 0 &#125;); &#125; return snake;&#125; 我们主要的源 Observable 是 ticks$，每当管道上有新值发出，我们就取 direction$ 和 snakeLength$ 的最新值。注意，即使辅助流频繁地发出值(例如,玩家头撞键盘上)，也只会在每次定时器发出值时处理数据。 此外，我们给 withLatestFrom 传入了选择器函数，当主要的流产生值时才会调用此函数。此函数是可选的，如果不传，将会生成包含所有元素的列表。来看下Marbles图： 可以看到，使用了withLatestFrom()后，只有当ticks$发出值时，才会去direction$和snakeLength$中取最近的值一起发出，然后经过scan()处理，生成蛇身的数组对象形式的流。 score$流玩家的比分比较好处理，有了snakeLength$我们直接使用scan()积累一下分数即可，每当snakeLength$发出值，累加一次分数： 12345const POINTS_PER_APPLE = 1; // 每次一分let score$ = snakeLength$.pipe( startWith(0), // 初始0分 scan((score, _) =&gt; score + POINTS_PER_APPLE)); 来看下Marbles图： 这里看似简单，其实有点小坑。可以看到score$中没有出现snakeLength$流中数据5对应的分数，这是因为snakeLength$使用了share()来允许多次订阅它，同时snake$已经先行订阅了snakeLength$，这时候score$的订阅就只会先发出startWith(0)初始化的数据0，只有等到length$.next(POINT)发出值，snakeLength$发出6，score$才会同步发出分数1，仔细体会一下。 apples$流snake$和score$已经搞定，剩下的就是apples$流。先确定一下apples$的数据格式，我们需要在canvas中同时显示两个苹果，同时，如果蛇吃到了苹果，则会在页面中非蛇身的位置随机产生另外一个苹果。所以我们使用[{x: *, y: *}, {x: **, y: **}]数组对象的格式来表示苹果。每次蛇移动时都检查是否有碰撞。如果有碰撞，我们就生成一个新的苹果并返回一个新的数组。这样的话我们便可以利用 distinctUntilChanged() 来过滤掉完全相同的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445let apples$ = snake$.pipe( scan(eat, generateApples()), distinctUntilChanged(), // apples$会随着snake$发出值而发出，过滤重复值 share() // apples$也会被applesEaten$和scene$订阅，使用share()保持数据一致);// utils.tsexport function eat(apples: Array&lt;Point2D&gt;, snake) &#123; let head = snake[0]; for (let i = 0; i &lt; apples.length; i++) &#123; if (checkCollision(apples[i], head)) &#123; apples.splice(i, 1); return [...apples, getRandomPosition(snake)]; &#125; &#125; return apples;&#125;export function generateApples(): Array&lt;Point2D&gt; &#123; let apples = []; for (let i = 0; i &lt; APPLE_COUNT; i++) &#123; apples.push(getRandomPosition()); &#125; return apples;&#125;// 获取随机位置export function getRandomPosition(snake: Array&lt;Point2D&gt; = []): Point2D &#123; let position = &#123; x: getRandomNumber(0, COLS - 1), y: getRandomNumber(0, ROWS - 1) &#125;; if (isEmptyCell(position, snake)) &#123; return position; &#125; return getRandomPosition(snake);&#125;// 检测是否碰撞，即两点是否一致export function checkCollision(a, b) &#123; return a.x === b.x &amp;&amp; a.y === b.y;&#125;function isEmptyCell(position: Point2D, snake: Array&lt;Point2D&gt;): boolean &#123; return !snake.some(segment =&gt; checkCollision(segment, position));&#125;function getRandomNumber(min, max) &#123; return Math.floor(Math.random() * (max - min + 1) + min);&#125; 每当 apples$ 产生一个新值时，我们就可以假定蛇吞掉了一个苹果。剩下要做的就是增加比分，还要将此事件通知给其他流，比如 snake$，它从 snakeLength$ 中获取最新值，以确定是否将蛇的身体变长。 appleEaten$流我们在上面的eat方法中检测到了“碰撞”，即蛇吃到了苹果。这时候我们应该调用length$.next(POINTS_PER_APPLE)去增加蛇的长度snakeLength$，但是我们把eat工具方法整合到了utils.ts文件内，无法调用到length$.next()，这个时候我们可以引入一个中间流，让它帮我们通知。 appleEaten$扮演了这个角色，首先，因为appleEaten$订阅的是apples$流，apples$刚开始就有一个初始值发出，我们需要跳过这个初始值，不然一开局比分就会增加，显然不行；其次，appleEaten$只负责扮演通知者的角色，它只负责通知其他的流，而不会有观察者来订阅它。因此，我们需要手动订阅。 1234let appleEaten$ = apples$.pipe( skip(1), // 跳过第一个apples值，即初始值 tap(() =&gt; length$.next(POINTS_PER_APPLE)) // 每次apples发出值，都让length$ next出去一分).subscribe(); scene$流回头再看一次上面的snake流图，基本上所有的流都已完成，而且形成了一整套闭环。只差之后的的整合流scene$了。先来看下代码： 1let scene$ = combineLatest(snake$, apples$,score$, (snake, apples, score) =&gt; (&#123; snake, apples, score &#125;)); 与 withLatestFrom 不同的是，我们不会限制辅助流，我们关心每个输入 Observable 产生的新值。最后一个参数还是选择器函数，我们将所有数据组合成一个表示游戏状态的对象，并将对象返回。游戏状态包含了 canvas 渲染所需的所有数据。 性能维护无论是游戏，还是 Web 应用，性能都是我们所追求的。性能的意义重大，但就我们的游戏而言，我们希望每秒重绘整个场景 60 次。所以我们需要另外一个定时器去限制渲染频率： 123// interval 接收以毫秒为单位的时间周期，这也就是为什么我们要用 1000 来除以 FPSconst FPS = 60;interval(1000 / FPS); 问题是 JavaScript 是单线程的。最糟糕的情况是，我们阻止浏览器执行任何操作，导致其锁定。换句话说，浏览器可能无法快速处理所有这些更新。原因是浏览器正在尝试渲染一帧，然后立即被要求渲染下一帧。作为结果，它会抛下当前帧以维持速度。这时候动画就开始看上去有些不流畅了。 幸运的是，我们可以使用 requestAnimationFrame 来允许浏览器对任务进行排队，并在最合适的时间执行任务。但是，我们如何在 Observable 管道中使用呢？好消息是包括 interval() 在内的众多操作符都接收 Scheduler (调度器) 作为最后的参数。总而言之，Scheduler 是一种调度将来要执行的任务的机制。 虽然 RxJS 提供了多种调度器，但我们关心的是名为 animationFrame 的调度器。此调度器在 window.requestAnimationFrame触发时执行任务。 1const game$ = Observable.interval(1000 / FPS, animationFrame) 现在interval大概每 16ms 发出一次值，从而保持 FPS 在 60 左右。 场景渲染最后，我们把game$和scene$组合起来。game$作为主要流，每隔1000/FPS毫秒时，根据scene$数据渲染一次页面，所以使用withLatestFrom()组合： 12345678const game$ = interval(1000 / FPS, animationFrame) .withLatestFrom(scene$, (_, scene) =&gt; scene) .takeWhile(scene =&gt; !isGameOver(scene)) // 蛇身蛇头相碰，则游戏结束 .subscribe(&#123; next: (scene) =&gt; renderScene(ctx, scene), // canvas渲染页面 complete: () =&gt; renderGameOver(ctx) // 渲染游戏结束页面 &#125;);// isGameOver、renderScene和renderGameOver方法在稍后的超链接中可以找到，这里略去 至此，我们就使用RxJS完成了整个游戏的核心部分，完全使用响应式编程，没有依赖任何外部状态。 这里是在线试玩的 demo。 总结&amp;资料引入在花了两三周时间把RxJS的基础概念和操作符都过了一遍之后，急需一个实例demo来将自己所学的RxJS知识进行转化，只有真正的操作过，使用过，才能更深入的理解Observable和响应式编程的理念。最后在知乎上找到了一篇RxJS 游戏之贪吃蛇的专栏文章，自己跟着做了一遍，反复思考其中流的起源、转换和走向。这篇博客基本上是按照RxJS 游戏之贪吃蛇一文中的思路整理的，其中加入了我自己的思考过程，极力推荐阅读原文。以下是本文的参考资料： RxJS 游戏之贪吃蛇、RxJS官方api文档、30 天精通 RxJS、RxJS Marbles、学习 RxJS 操作符、贪吃蛇源码 以上的链接也是我最近几周所看所学的来源。接下来会写几篇博客进行知识点的总结，掺杂一些自己的思考，巩固自己所学，加深印象。]]></content>
      <tags>
        <tag>知识积累</tag>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《记忆化技术memoize-one》]]></title>
    <url>%2F2018%2F10%2F11%2F%E3%80%8A%E8%AE%B0%E5%BF%86%E5%8C%96%E6%8A%80%E6%9C%AFmemoize-one%E3%80%8B%2F</url>
    <content type="text"><![CDATA[最近在努力学习react中，各种工具概念应接不暇：react-redux、dva、umi、redux-saga、ant design pro…每一个都需要耗费时间去接触熟悉。上个月常刷的leetCode刷到中等难度题也开始屡屡碰壁，果然罗马不是一天建成的，还是要不断跳出舒适区，不断折腾才能前进。 引入场景平时在开发中，少不了前端对服务器传来的数据进行处理整合，然后丢给框架去render。react配合redux开发时，外层容器组件的props改变时，都会调用render()去diff渲染。假如我们在render()内进行了复杂的数据处理： 1234567891011121314151617181920import React, &#123; PureComponent &#125; from 'react';class TableList extends PureComponent &#123; state = &#123; filterText: "" &#125;; handleChange = event =&gt; &#123; this.setState(&#123; filterText: event.target.value &#125;); &#125;; render() &#123; const filteredList = this.props.list.filter( item =&gt; item.text.includes(this.state.filterText) ) //过滤数据 const filteredList = list.filter(item =&gt; item.name === this.state.filterName) return ( &lt;Fragment&gt; &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.filterText&#125; /&gt; &lt;ul&gt;&#123;filteredList.map(item =&gt; &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/li&gt;)&#125;&lt;/ul&gt; &lt;/Fragment&gt; ) &#125;&#125; 每一次render()都会去过滤一次数据，假如我们这个组件的title经常变化，但是list数据不变，就会消耗大量计算时间，导致性能问题。 而在实际的开发中，数据结构往往更加复杂，有时候甚至会有多次的循环。有时候组件的更新并不是因为从服务器拿来的这一段数据结构发生变化造成的（组件中的其他部分更新造成的），但是这一段很重的逻辑因为是写在 render 中的，所以不可避免的在每次 render 会调用一次。如果这段逻辑在两次调用的时候，输入参数是一样的，那么输出结果必然一样，所以再次计算是一种十分浪费资源的行为。 接下来我们使用记忆化技术来优化。 记忆化库-memoize-one根据memoize-one名字中的one可以知道，这个库的每个实例都缓存了一个结果，下一次不同的结果将覆盖上一次的。虽然只能缓存一个数据，但是用到合适的地方却能发挥很大的作用。 使用npm安装：$ npm install memoize-one，先看一下官方例子： 1234567891011121314151617181920import memoizeOne from 'memoize-one'; const add = (a, b) =&gt; a + b;const memoizedAdd = memoizeOne(add); memoizedAdd(1, 2); // 3 memoizedAdd(1, 2); // 3// Add 函数并没有执行: 前一次执行的结果被返回 memoizedAdd(2, 3); // 5// Add 函数再次被调用以获得新的结果 memoizedAdd(2, 3); // 5// Add 函数并没有执行: 前一次执行的结果被返回 memoizedAdd(1, 2); // 3// Add 函数再次被调用以获得新的结果// 虽然之前调用过// 但是不是上一次调用的，所以结果丢失了 memoizeOne(resultFn, isEqual)接收一个结果函数和一个对比函数，对比函数为空则默认使用===来进行入参的比较。 简单来讲就是，memoizeOne()在原来resultFn()函数外面包了一层，返回一个函数，然后每次调用的时候看新入参newArgs是否和上一次的入参lastArgs一致，参数不变，则直接返回缓存的结果，否则重新执行resultFn(newArgs)，缓存新结果。 简单改造一下上面的例子： 12345678910111213141516171819202122import React, &#123; Component &#125; from 'react';import memoizeOne from 'memoize-one';class TableList extends Component &#123; state = &#123; filterText: "" &#125;; handleChange = event =&gt; &#123; this.setState(&#123; filterText: event.target.value &#125;); &#125;; filter = memoize( (list, filterText) =&gt; list.filter(item =&gt; item.text.includes(filterText)) ); render() &#123; const &#123; list, title &#125; = this.props; //当list和filterName不变时，filteredList返回值不变 const filteredList = this.filter(list, this.state.filterText); return ( &lt;Fragment&gt; &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.filterText&#125; /&gt; &lt;ul&gt;&#123;filteredList.map(item =&gt; &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/li&gt;)&#125;&lt;/ul&gt; &lt;/Fragment&gt; ) &#125;&#125; 这样就简单的实现了一个记忆优化。 源码解读memoize-one记忆库巧妙的使用了闭包来实现，一般我是不看源码的，但是这个库的源码只有不到40行的代码，简单易懂，这里就简单看一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243//isEqual比较函数，用来判断参数是否一致，默认使用全等来判断var simpleIsEqual = function simpleIsEqual(a, b) &#123; return a === b;&#125;;function index (resultFn, isEqual) &#123; //不传isEqual，使用默认的内置函数 if (isEqual === void 0) &#123; isEqual = simpleIsEqual; &#125; var lastThis; var lastArgs = []; //上一次的入参 var lastResult; //缓存的结果 var calledOnce = false; //是否调用过，区分第一次 //判断两次入参是否相等，使用了every方法，这个是every方法的函数 var isNewArgEqualToLast = function isNewArgEqualToLast(newArg, index) &#123; return isEqual(newArg, lastArgs[index]); &#125;; var result = function result() &#123; //将入参arguments按顺序一个个存入newArgs内 for (var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key &lt; _len; _key++) &#123; newArgs[_key] = arguments[_key]; &#125; //入参不变，直接返回缓存的结果lastResult if (calledOnce &amp;&amp; lastThis === this &amp;&amp; newArgs.length === lastArgs.length &amp;&amp; newArgs.every(isNewArgEqualToLast)) &#123; return lastResult; &#125; lastResult = resultFn.apply(this, newArgs); //apply到resultFn,传入参数newArgs，缓存结果 calledOnce = true; lastThis = this; //this？ lastArgs = newArgs; //新入参替换缓存的参数 return lastResult; //返回新计算的结果 &#125;; return result; //返回一个函数，闭包，不被GC&#125;export default index; 源码还是比较容易看懂的。 isEqual函数因为对相等的理解，不同场景不一样，而且参数有时候是复杂的对象，所以我们不能仅仅通过比较操作符 == 或者 === 来判断。memoize-one 允许用户自定义传入判断是否相等的函数，比如我们可以使用 lodash 的 isEqual 来判断两次参数是否相等。 1234567891011121314151617import memoizeOne from 'memoize-one';import deepEqual from 'lodash/isEqual'; const identity = x =&gt; x; const defaultMemoization = memoizeOne(identity);const customMemoization = memoizeOne(identity, deepEqual); const result1 = defaultMemoization(&#123;foo: 'bar'&#125;);const result2 = defaultMemoization(&#123;foo: 'bar'&#125;); result1 === result2 // false - 索引不同 const result3 = customMemoization(&#123;foo: 'bar'&#125;);const result4 = customMemoization(&#123;foo: 'bar'&#125;); result3 === result4 // true - 参数通过 lodash 的 isEqual 判断是相等的 参考链接：what-about-memoization，记忆化技术介绍——使用闭包提升你的 React 性能]]></content>
      <tags>
        <tag>知识积累</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《git常用操作命令总结》]]></title>
    <url>%2F2018%2F09%2F09%2F%E3%80%8Agit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%E3%80%8B%2F</url>
    <content type="text"><![CDATA[git工作流现在已经成了大大小小科技型公司的标配，程序员日常撸代码必备工具。不同的公司根据业务的展开及开发的进度都会制定最合适的git流程。上家公司开发人员少，流程基本就是develop-&gt;release-&gt;master，有线上bug修复，就基于master拉hotfix分支，测完之后通过gitlab合并回master和develop分支，基本上属于单线操作，简单清晰。到新公司后，开发需求数倍增加，开发人员也比较多，各种流程繁杂，需要合并分支，处理冲突，多线开发的情况也越来越多。以往学习的那点git知识已经不能满足现在的开发了（其实就是git学的不精），最近又重新把git流程过了一遍，今天来总结一下。 几个基础概念工作区及文件状态git分为三个工作区域：工作区 Working Directory、暂存区 Staging Area、GIT仓库 repository，git仓库又有本地和远程的概念，一般来讲，本地仓库会领先于远程仓库，不过也有例外情况，下面再具体讲。 git的文件状态。git仓库中的文件，不外乎这几种状态： Untracked 未追踪，即新建一个a.js文件，还没有被git追踪，不会到版本库内。 Unmodified 未修改，该文件在git版本库内，但是还没有被修改。 modified 已修改，该文件在git版本库，已经修改，但还没有暂存。 Staged 已暂存，有修改的文件已经通过git add &lt;file&gt;添加到暂存区。 仓库内文件的状态可以通过git status查看。 a.js是新增的文件，还没有被追踪，c.js修改了，但是还没有添加到暂存区，b.js修改后已经添加到暂存区，此时commit将只会提交b.js。 快照流每次提交保存时，git主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 各种撤消针对不同情况的撤消操作命令，在git status中都能看到，这里来总结一下： git rm &lt;file&gt; ：将某个已被追踪的文件删除，提交之后该文件不会再被追踪，同时本地也会删除该文件。 git rm --cached &lt;file&gt; : 同上，不再追踪某个文件，但是本地磁盘内不会删除该文件，回到Untracked状态。 git checkout -- &lt;file&gt; : 将整个文件的修改恢复，慎用，modified -&gt; unmodified，一般使用IDE工具修改最好。 git reset HEAD &lt;file&gt; : 将暂存区的文件回退至已修改状态，staged -&gt; modified，文件add之后回退可用。 git reset --hard HEAD^ : 回退到上个版本，commit之后算一个版本。 git reset --hard commit_id : 移动HEAD指针，会退到指定commit_id的版本。 git commit --amend : 覆盖之前的提交信息，运行此命令会将暂存区文件提交，同时启动vim编辑器，可以编辑上一次的提交信息，最终提交记录里只会有这一次修改后的信息。 打标签Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。工作中可以给某次提交打上标签，运维发布线上代码时会以此为准。 git tag ：列出所有标签。 git tag -l release ：列出所有包含release字段的tag。 git tag -a v1.0 -m &#39;my v1.0 version&#39; : 创建附注标签，使用git show v1.0查看详细信息。 git tag v1.0 ：创建轻量标签。 git tag v1.0 commit_id ： 给某个历史提交commit_id打标签，可以使用git log --pretty=online查看历史请求。 git push origin [tagname] : 推送单个标签到远端 git push origin --tags ： 推送所有本地标签到远端 git checkout -b [branchname] [tagname] : 在特定的标签上创建一个新分支 分支操作分支操作比较常用，总结一下命令行： git branch develop : 新建develop分支，但是不切换。 git checkout master : 切换至master分支。 git checkout -b develop ：基于当前分支新建develop分支，并切换至develop分支。 git branch -d dev ：删除dev分支。 git branch -r ：查看远程分支列表 git checkout -b iss53 origin/iss53 : 拉取远端分支iss53并在本地新建该分支。 git checkout --track origin/iss53 : 同上，简化版本。 git push -u origin iss54 : 推送本地分支iss54至远程仓库origin/iss54，同时建立追踪关系。 git push origin --delete iss54 : 删除远程分支iss54 合并及处理冲突合并先来张合并图： 上图展示了将iss53分支合并至master分支的过程。首先切换到master分支，保证master分支最新，然后git merge iss53，此时Git 会使用两个分支的末端所指的快照（commit6和 commit4-hotfix）以及这两个分支的工作祖先（commit3），做一个简单的三方合并。 注意观察指针的位置，此时master分支指向了commit7，iss53仍然指向commit6的位置，这就是平时开发最常见的情况，保留自己的开发分支进度，同时将自己的代码合并回提测/上线分支。问题来了，如果我反向合并呢？即在iss53分支上运行git merge master呢？ 考虑一下这种场景：你的同事开发了一个需求A，并且已经通过上面的方式将他的代码合入了master分支；你负责的需求B此时开发了一半，突然发现有一个地方需要基于需求A的代码才能继续进行。这时候就可以将master上的代码合入你自己的分支iss53，此时你的代码已经包含了master中commit的代码，流程图如下： 如果之后master分支再没有任何代码合入，你的需求开发完之后，合入master分支时将会是一次fast-forward合并，master的指针会直接快进指向iss53所在的位置。 另一个需要注意的是：代码合并时合并的只是你之前commit提交的代码修改，只对比这些文件。 解决冲突代码为什么冲突，用上图举例来说，自commit3之后，master分支和iss53分支分别有commit4-hotfix和commit5/6提交，如果这两个分支提交中修改了同一个文件的相同位置，则会报文件有冲突，需要解决冲突才能继续合并。解决流程就是：先手动解决文件a的冲突，然后git add a.js，接着git commit -m &#39;fix conflict&#39;即可，此时可以推送到远端仓库。可以通过git status查看未解决冲突的文件。 这个过程中可以通过git merge --abort来终止合并。 解决冲突最重要的是要细心，要仔细查看git status未解决冲突的文件，一一去解决。如果不加思索的直接git add .，则会将未解决冲突的文件移动到暂存区，然后提交上去。如果又推送到了远程仓库，处理起来会比较麻烦。如果遇到这种情况，可以用以下方法解决： 在本地master分支上git reset --hard HEAD^，回退这次提交。 git push -f，强制推送本地分支到远端。因为这个时候你的本地分支已经落后于远端分支，如果正常流程git pull，你的代码会回到冲突后的提交状态，相当于白白reset了代码。如果直接使用git push，git会提示你本地分支落后于远端，必须git pull才能推送。使用git push -f，强制将远程仓库的代码替换为你当前本地分支的代码，相当于远端代码reset回退。 再次git merge iss53，将代码合并回master，解决冲突，add -&gt; commit -&gt; push。 以上方法建立在你的冲突代码推送到远端后，你的队友没有人再次合并代码到master并且推送到远端。如果有这种情况，处理起来会更复杂，因为你的回退，然后强制推送，会将他们的代码回退掉！这时候就需要每一个队友的共同配合才能解决，异常复杂和麻烦。所以一定要细心细心再细心，尽量不要reset。 储藏与清理有这样一个场景，你在你的分支iss54上开发需求，改了好多文件代码，这个时候老大来告诉你，develop分支上有个地方有问题，需要你去确认一下。一般这时候你切换分支是无法切换的，git会提示你先暂存才可以。但是你暂时又不想提交，因为提交过之后你的修改记录就没有了，下次再切换回来，哪些文件调整过，在IDE里就无法清晰的看到。这个时候你可以使用git stash相关命令： git stash : 将当前分支的修改先储存到栈内(清理一下工作区)，方便切换分支。 git stash list : 查看栈内储存列表。 git stash apply : 应用最近的一次储存，之前暂存过的文件会回到modified状态。 git stash apply --index : 恢复到储存时的状态，包括已经暂存的文件状态。 git stash apply stash@{2} : 应用指定的储存。 git stash drop stash@{0} : 删掉栈内指定的储存。 思维导图总结 以上的命令及处理方法基本上已经可以满足日常的开发了。之前命令行用的少，都是使用IDE内自带的可视化工具来操作，虽然比较简单明了，但速度是无法跟命令行比的。不过使用IDE可以方便的切换分支，拉取远端分支，提示未解决的冲突等，日常使用要方便的多。推荐两者结合着使用，毕竟我们的目的是把工作做好，把任务完成，在git上不必过分纠结于过程。 参考：git]]></content>
      <tags>
        <tag>随写</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4.0 从入门到进阶三]]></title>
    <url>%2F2018%2F08%2F08%2Fwebpack4-0-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6%E4%B8%89%2F</url>
    <content type="text"><![CDATA[上两篇博客简单总结了webpack4.0的一些基础配置，写完之后对webpack有了一个入门的认识。这两天又继续对遗留的几个知识点进行了梳理，如两种开发模式的配置流程，path和publicPath的区别与作用等。但是看一些关于webpack运行原理的博客时还是会一脸懵逼，完全不知所云，而且目前来讲我并没有真正的从0配置一个webpack的项目，所有的这些知识点还都没进入实践去检验。接下来写完这一两篇博客后，会着手开始react框架的学习，到时候结合项目，再去深入的理解webpack。 生产模式&amp;&amp;开发模式现代前端工程项目，不管是使用angular-cli还是vue-cli来搭建，都会有本地开发和线上生产两种模式，命令行运行npm run dev即可在本地起一个服务，方便本地开发调试。之前讲webpack4.0新增了mode模式，之后会简化两种模式的配置，但是我们还是先来看一下4.0之前是如何配置两种模式的配置文件的，这里以vue为例。 vue的最佳实践vue-cli脚手架生成的工程项目结构非常清晰，值得反复看，反复理解，它关于生产和开发模式的配置主要是这些文件： webpack.base.conf.js中是一些公共的配置，然后通过webpack-merge把这些公共配置项和环境特定的配置项 merge 起来，成为一个完整的配置项。比如在webpack.dev.conf.js中： 1234567'use strict'const merge = require('webpack-merge')const baseWebpackConfig = require('./webpack.base.conf')const devWebpackConfig = merge(baseWebpackConfig, &#123; ...&#125;) 通过这种方式，开发和生产两种模式就可以有各种独有的wenpack配置项，更关键的是，每个配置中用 webpack.DefinePlugin 向代码注入了 NODE\_ENV 这个环境变量。这个变量在不同环境下有不同的值，比如 dev 环境下就是 development。这些环境变量的值是在 config 文件夹下的配置文件中定义的。Webpack 首先从配置文件中读取这个值，然后注入。比如这样： 123456//webpack.dev.conf.jsplugins: [ new webpack.DefinePlugin(&#123; 'process.env': require('../config/dev.env.js') &#125;),] 12345678//dev.env.js'use strict'const merge = require('webpack-merge')const prodEnv = require('./prod.env')module.exports = merge(prodEnv, &#123; NODE_ENV: '"development"'&#125;) 这样我们就可以根据当前环境做判断，执行不同逻辑的代码，比如这样： 12345678//utils.js// 根据环境使用不同资源地址assetsSubDirectoryexports.assetsPath = function (_path) &#123; const assetsSubDirectory = process.env.NODE_ENV === 'production' ? config.build.assetsSubDirectory : config.dev.assetsSubDirectory return path.posix.join(assetsSubDirectory, _path)&#125; 这种区分不同的环境，并给环境变量设置不同的值的实践，让我们开启了编译时按环境对代码进行针对性优化的可能。 模拟4.0之前看的再多不如手写一遍。我们先来手动实现vue的模式。首先我们安装两个依赖： 1npm i webpack-merge uglifyjs-webpack-plugin -D 然后新建webpack.dev.conf.js和webpack.prod.conf.js两个文件，同时将webpack.conf.js修改为webpack.base.conf.js: 我们将devServer配置移动到webpack.dev.conf.js中，同时新增一个devtool配置： 12345678910111213141516const path = require('path');const merge = require('webpack-merge');const baseWebpackConfig = require('./webpack.base.conf')module.exports = merge(baseWebpackConfig, &#123; mode: 'development', devServer: &#123;//配置此静态文件服务器，可以用来预览打包后项目 inline:true,//打包后加入一个websocket客户端 contentBase: path.resolve(__dirname, 'dist'),//开发服务运行时的文件根目录 host: 'localhost',//主机地址 port: 4200,//端口号 compress: true,//开发服务器是否启动gzip等压缩 open:true, // 自动打开浏览器 &#125;, devtool: 'cheap-module-eval-source-map'&#125;) 使用webpack-merge合并基础配置和开发配置，这里就简单这么配置。接下来配置一下webpack.prod.conf.js： 12345678910111213141516171819const merge = require('webpack-merge');const baseWebpackConfig = require('./webpack.base.conf.js');const UglifyJsPlugin = require('uglifyjs-webpack-plugin');module.exports = merge(baseWebpackConfig, &#123; mode: 'production', devtool: '#source-map', plugins: [ new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false &#125; &#125;, sourceMap: true, parallel: true &#125;) ]&#125;) 这里我们配置了一个不同的devtool配置，然后新引入一个uglifyjs-webpack-plugin插件，用来压缩混淆js文件。最后我们为了方便测试效果，将package.json中的命令这么修改： 123456... "scripts": &#123; "dev": "webpack --config webpack.dev.conf.js", "build": "webpack --config webpack.prod.conf.js" &#125;,... 接下来我们分别运行npm run dev和npm run build，观察生成的dist文件夹有什么不同： 从这个简单的实践我们就实现了一个很粗糙的运行模式拆分。剩下的就是针对具体的项目需求来编写更加强大的webpack配置了，当然还是强烈推荐去看vue脚手架生成的项目结构，越看越觉得有收获。 webpack4.0模式初探webpack4.0新增了mode配置，可选值有development/production/none，借用官方文档： 选项 配置 development 会将 process.env.NODE_ENV 的值设为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。 production 会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin. none 不选用任何默认优化选项 在不同的模式下，webpack会自动执行不同的插件： mode: development 123456789// webpack.dev.conf.jsmodule.exports = &#123;+ mode: 'development'- plugins: [- new webpack.NamedModulesPlugin(),- new webpack.NamedChunksPlugin(),- new webpack.DefinePlugin(&#123; "process.env.NODE_ENV": JSON.stringify("development") &#125;),- ]&#125; mode: production 12345678910// webpack.production.config.jsmodule.exports = &#123;+ mode: 'production',- plugins: [- new UglifyJsPlugin(/* ... */),- new webpack.DefinePlugin(&#123; "process.env.NODE_ENV": JSON.stringify("production") &#125;),- new webpack.optimize.ModuleConcatenationPlugin(),- new webpack.NoEmitOnErrorsPlugin()- ]&#125; mode: none 123456// webpack.custom.config.jsmodule.exports = &#123;+ mode: 'none',- plugins: [- ]&#125; 如果你想要根据 webpack.config.js 中的 mode 变量去影响编译行为，那你必须将导出对象，改为导出一个函数： 1234567891011121314151617var config = &#123; entry: './app.js' //...&#125;;module.exports = (env, argv) =&gt; &#123; if (argv.mode === 'development') &#123; config.devtool = 'source-map'; &#125; if (argv.mode === 'production') &#123; //... &#125; return config;&#125;; 但是这个选项的加入，如何优雅的跟之前拆分文件的形式结合，还得看社区大神们的整合方式，不管怎样，以后遇到心里就有底了。 path &amp;&amp; publicPath先来看一下现在我们output配置： 1234567891011const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: "[chunkhash].bundle.js", publicPath: '/' &#125;, ...&#125; output配置中path指定了webpack打包后生成的文件输入到哪里，我们之前运行npm run build的时候，文件都是打包到了这里，这个比较好理解，不过需要注意的是，该路径必须为绝对路径，所以我们使用了path.resolve来输出。 简单了说完了，比较迷惑的publicPath来了，这个路径指什么呢？刚开始我也比较迷惑，path已经配置了，还要这个publicPath干什么？反正你静态资源（css、image）都是以此为基准嘛，等等，真的是这样吗？ 我们先来运行一下npm run dev，注意，这时候我们把命令调回到webpack-dev-server，同时，我们设置output内publicPath的值为&quot;/&quot;，该值不设置的话默认为空字符串。 1"dev": "webpack-dev-server --config webpack.dev.conf.js" 服务启动后，打开控制台，观察html、css和image的加载路径： 这里无法一次看完，手动写一下，第一个localhost即document文件路径是http://localhost:4200/，第二个style.css即stylesheet文件路径是http://localhost:4200/static/css/style.css?4cb..，第三个wp7.png即png文件路径是http://localhost:4200/static/img/wp7.png。 这里我们发现，所有的静态资源文件路径都是基于/，即我们设置的publicPath，这个配置指定了你上传所有打包文件的位置（相对于服务器根目录），不过要注意，有时候我们的项目可不一定就是在网站根目录下配置的啊，有时候我们做的项目可能在xxx.com/project/下面部署，如果你不相应的修改publicPath值为/project/，你会发现静态资源路径依然会基于/，即根目录，从而导致资源无法访问到。 我们来试一试，现在将publicPath改为&quot;/project/&quot;，再来运行npm run dev，发现页面空白，显示Cannot GET/，控制台内也是404，这时候我们访问http://localhost:4200/project/，页面加载成功，再看控制台： 所有的资源路径都是在/project/下。 这里面其实涉及到了项目打包部署的问题，我对这方面了解的比较少，所以前面才会一直搞不明白这个publicPath是干什么的，最近翻了翻vue脚手架项目，又反复测试，才渐渐有点理解。不过这里面确实需要不断的实践才能更好的理解，就如官方文档中举的例子： 123456789101112module.exports = &#123; //... output: &#123; // One of the below publicPath: 'https://cdn.example.com/assets/', // CDN（总是 HTTPS 协议） publicPath: '//cdn.example.com/assets/', // CDN（协议相同） publicPath: '/assets/', // 相对于服务(server-relative) publicPath: 'assets/', // 相对于 HTML 页面 publicPath: '../assets/', // 相对于 HTML 页面 publicPath: '', // 相对于 HTML 页面（目录相同） &#125;&#125;; 上面还涉及到了资源在CDN的情况，理解了这些，以后就可以愉快的配合运维同学一起部署上线了，再遇到问题，查看官方文档就有迹可循了。 webpack系列暂时告一段落，但是绝不是结束，后续的运行原理还等着我去研究和学习，到现在为止，感觉继续单纯的纸上谈兵已经不能有较大的提升了，接下来就是到项目中去，结合项目进行学习，巩固和调整。 参考文章：官方中文文档，Webpack 4 配置最佳实践]]></content>
      <tags>
        <tag>随写</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4.0 从入门到进阶二]]></title>
    <url>%2F2018%2F08%2F06%2Fwebpack4-0-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[上一篇讲了webpack配置Html模板和css文件的方法，配置Html模板需要用到html-webpack-plugin插件，可以选择一个静态html文件作为模板；而配置css文件分为使用&lt;style&gt;&lt;/style&gt;标签插入样式和使用link方式引入css文件，这里面依次要使用到css-loader、style-loader和less-loader(根据css预处理语言的不同)。webpack.config.js文件的配置项比较多，比较复杂，需要我们根据不同的场景去查阅相应的文档去实现功能。今天这篇我们继续来讲webpack4.0的配置。 清理dist文件夹开始之前我们先来配置clean-webpack-plugin插件，这个插件的作用是在每次生成dist文件的时候先将该文件夹清空，然后再生成新的静态文件： 1npm i clean-webpack-plugin -D 安装完后进行简单的配置： 1234567891011...const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; ... plugins: [ ... // 打包前先清空dist文件 new CleanWebpackPlugin('dist') ]&#125; 这样每次运行npm run build就不会重复在dist文件夹内生成文件了。 webpack-dev-server为了方便我们本地调试代码，我们抽两分钟时间来具体配置一下webpack-dev-sever，上一篇的时候我们已经安装好了webpack-dev-server，我们现在做以下配置： 12345678910111213module.exports = &#123; mode: 'development', devServer: &#123; //配置此静态文件服务器，可以用来预览打包后项目 inline:true, //打包后加入一个websocket客户端 contentBase: path.resolve(__dirname, 'dist'), //开发服务运行时的文件根目录 host: 'localhost', //主机地址 port: 4200, //端口号 compress: true //开发服务器是否启动gzip等压缩 open:true, // 自动打开浏览器 &#125;, entry: './src/index.js', ...&#125; 具体其他配置可以去查看文档，以上的配置已经足够我们来使用。 还有一点要注意的是，webpack4.0新增了mode配置，可选development/production两种模式，还记得vue脚手架里面的webpack.dev.conf.js和webpack.prod.conf.js吗？就是为了区分不同的模式进行了配置的拆分，现在4.0加入mode选项，也是对社区最优选择的一种肯定，接下来会再写博客单独对这里进行探究。 图片资源的配置处理图片的时候，我们需要另外的loader，先使用npm安装： 1npm i url-loader file-loader -D 先来说下这两个loader的区别，file-loader可以解析项目中的url引入（不仅限于css），根据我们的配置，将图片拷贝到相应的路径，修改打包后文件引用路径，使之指向正确的文件。url-loader相当于file-loader的又一层封装，且url-loader可以单独使用，不必依赖于file-loader，url-loader的作用是在图片大小小于limit值的时候将图片转为base64图片，大于limit的时候使用file-loader来处理图片，这样可以减少图片的http请求数量。来看看例子： 12345678910111213141516171819202122232425262728module: &#123; rules: [ ... &#123; test: /\.(jpg|png|jpeg|gif)$/, loader: 'file-loader', options: &#123; // 这里将图片资源统一放入dist/static/img内 name: 'static/img/[name].[ext]' &#125; &#125;, // 或者使用url-loader &#123; test: /\.(jpg|png|jpeg|gif)$/, loader: 'url-loader', options: &#123; // 小于8k的图片转为base64 limit: 8192, name: 'static/img/[name].[ext]' &#125; &#125;, // url-loader也可以使用query的形式带入配置参数 &#123; test: /\.(jpg|png|jpeg|gif)$/, loader: 'url-loader?limit=8192&amp;name=static/img/[name].[ext]' &#125;, ] &#125;, 写到这里的时候其实卡了很久，卡在了publicPath和样式内引入图片的问题（background-image）,这个后面可能会单独拿出来讲一下path和publicPath的区别和作用，涉及到了后台部署前端代码的一些问题，需要好好研究一番。 不光图片资源，我们的视频文件和字体文件也使用到了file-loader/url-loader，可以参照vue脚手架的设置： 123456789101112131415161718...&#123; test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('media/[name].[hash:7].[ext]') &#125;&#125;,&#123; test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125;&#125;,... 除了css内引入图片，我们也会在html文件内使用&lt;img src=&quot;img/a.png&quot; /&gt;或者内联样式的background来引入图片，这时候我们可以使用html-withimg-loader来处理这种情况： 1npm i html-withimg-loader -D 在webpack.config.js内配置： 1234&#123; test: /\.(html|htm)$/, loader: 'html-withimg-loader'&#125; 值得注意的是，该loader在NPM上已经有2年多没有更新了，而且在vue的脚手架内也没有找到这个loader的影子，那vue内是如何处理html内的图片的呢？留待研究。 ES6转义说完了图片资源的处理，我们来说一下对ES6代码的处理，也就是最重要的babel-core、babel-loader和babel-preset-env。这3个包是用来将ES6代码转为ES5的，方便兼容低版本浏览器的同时，也不影响我们使用最新的ES6去撸代码。首先安装： 1npm i babel-core babel-loader babel-preset-env -D 其中，babel-preset-env功能比较强大，可以指定我们的代码转义后需要兼容什么版本的浏览器，什么类型的浏览器等，配置项比较多，一般会将该配置单独另起一个.babelrc文件来存放。我们在根目录下新建一个.babelrc文件： 12345678910&#123; "presets": [ ["env", &#123; "modules": false, "targets": &#123; "browsers": ["&gt; 1%", "last 2 versions", "not ie &lt;= 8"] &#125; &#125;] ]&#125; 可以看到，转义后的es6代码支持浏览器份额大于1%，最近两个版本，且不是ie8以下。 在webpack.config.js内： 1234567891011module: &#123; rules: [ ... &#123; test: /\.js$/, loader: 'babel-loader', include: '/src/', //只转义src目录下的js文件 exclude: '/node_modules/' //排除掉node_modules目录 &#125; ]&#125; 注意，exclude优先级高于include。 写到这里，我们对webpack4.0的基本概念已经有了一个基本的认识，可以说我们已经入门了！不再一提webpack打包就一头雾水，手忙脚乱了。剩下的一些知识如resolve、热更新等概念，遇到了，不清楚，立马查文档，基础架子有了，剩下的就是加深理解了。 最后算下欠的账：一篇关于开发和生产模式的研究，一篇关于path和publicPath区别的博客，还有关于webpack更深入的一些知识总结，嗯，未完待续… 参考文章：webpack4-用之初体验，一起敲它十一遍，面试官：请手写一个webpack4.0配置]]></content>
      <tags>
        <tag>随写</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4.0 从入门到进阶一]]></title>
    <url>%2F2018%2F08%2F04%2Fwebpack4-0-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6%E4%B8%80%2F</url>
    <content type="text"><![CDATA[webpack4.0 从入门到进阶一好久没写博客了，一方面是最近在努力刷LeetCode题目，想通过做题来提升一下自己在算法方面的弱势，另一方面确实有点懒散了，公司的事情不多但是很杂。不管怎么说，这两天又静下来，准备深度学习一下webpack的相关知识，写几篇心得。说来惭愧，vue项目写过一两个，angular项目也写过几个，可对webpack基本上还是0的认知，vue-cli生成的项目基本上不需要自己去过多的配置，angular呢又找不到明显webpack配置文件，这就少了挑战自己的机会（还是懒），这次可要好好补上这个技能点。 webpack安装首先新建一个文件夹，命名webpack4.0，在文件内命令行运行： 1npm init -y 先生成一个默认配置的package.json，然后运行： 1npm install webpack webpack-cli --save-dev 这一步我们安装webpack和webpack-cli，需要注意的是webpack4+将webpack-cli单独拆了出来，所以要安装两个。这样就给项目安装好了webpack。 webpack.config.js接下来在目录下新建webpack.config.js配置文件，这里面就是webpack的基础和核心配置了，大致有这些配置： 123456789module.exports = &#123; entry: '', //入口文件 output: &#123;&#125;, //出口 module: &#123;&#125;, //处理模块，loader都在这里 plugin: &#123;&#125;, //强大的插件配置 devServer: &#123;&#125;, //开发服务器配置 mode: '', //模式配置， webpack4新增特性，有development/production ...&#125; 新建一个文件夹src，在里面新建一个index.js文件，作为我们的入口文件。这个文件其实不陌生，就是vue项目里的src-&gt;main.js文件，其实我们想想，项目的一切都是从这个文件开始的，main.js内import了许多文件（js，css…），然后这些js文件内又引入了其他文件，这样一层一层下去，所以这个文件就是一切开始的地方，webpack将从这里开始，一层一层将依赖找下去。 这个时候我们还需要一个devServer，来跑起来本地服务，运行以下命令： 1npm install webpack-dev-server --save-dev 接下里配置两条npm scripts，在package.json中： 123456..."scripts": &#123; "dev": "webpack-dev-server", "build": "webpack"&#125;,... 这样就开发环境run dev，生成线上打包资源run build。 现在准备工作差不多了，来从零手写webpack.config.js！ entry &amp;&amp; output我们先从最基础的地方入手，先来看看入口和出口的配置： 12345678const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[chunkhash].bundle.js' &#125;&#125; 大部分情况下，可以直接使用字符串的形式来实现单入口，路径基于当前项目根目录。如果有多个入口，则可使用entry: { app: &#39;./src/app.js&#39;, vendor: &#39;./src/vendor.js&#39;}这种对象形式。 入口可以多个，但是输出配置只能指定一个。filename指定了输出文件的文件名，有多种形式可选： 模板 描述 [hash] 模块标识符(module identifier)的 hash [chunkhash] chunk 内容的 hash [name] 模块名称 [id] 模块标识符(module identifier) [query] 模块的 query，例如，文件名 ? 后面的字符串 可以根据情况随心所欲的拼接。而输出目录path必须为绝对路径，这里使用了node的path（又一个盲点）来指定输出，这里指根目录下新建一个dist文件夹存放输出文件。 接下来就可以运行试一试了，我们先随便往index.js文件内写一些代码： 12const str = 'Hello Webpack';console.log(str); 现在我们的目录长这样： 命令行运行npm run build，可以看到在根目录下生成了dist文件夹，里面有根据我们在output内制定的文件名称格式的bundle文件： 配置Html模板可以想象，我们最后打包好的文件都将是js、css、image形式的，我们需要一个承载这些资源的文件，就是我们的html文件，我们需要实现html打包功能，我们引入html-webpack-plugin插件： 1npm i html-webpack-plugin -D 这是一个插件，我们在plugins内引用一下，同时在根目录下新建一个index.html文件作为模板： 123456789101112131415161718const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: "[chunkhash].bundle.js" &#125;, plugins: [ new HtmlWebpackPlugin(&#123; // 选择一个html文件作为模板 template: './index.html', // 在打包好的bundle.js后面添加hash hash: true &#125;) ]&#125; 再次运行npm run build，看看dist内生成的index.html文件。 可以看到页面内引入了chunkhash.bundle.js文件，同时页面也是使用我们在根目录下建的index.html作为模板。 现在来回想一下使用vue-cli起的脚手架，是不是有点感悟呢？ 配置CSS文件这里有两点需要知道，首先，如果我们想要将css文件单独拆出来，需要使用extract-text-webpack-plugin插件；其次，webpack打包css需要使用能解析css的loader，不同的css编译语言需要使用不同的loader，如less-loader、sass-loader等。 我们先来安装两个基础的样式loader: 1npm i css-loader style-loader -D 这两个loader各有分工：css-loader负责解释(interpret) @import 和 url() ，会 import/require() 后再解析(resolve)它们，style-loader负责将样式放入style标签内，放入DOM内。所以，我们需要先引入css-loader，再使用style-loader。 css文件css-loader&amp;style-loader&amp;less-loader在src文件夹内新建css-&gt;reset.css文件，里面随便写点样式，在src/index.js内通过import ‘./css/reset.css’引入，然后我们来配置loader: 1234567891011121314151617181920212223module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: "[chunkhash].bundle.js" &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; // 选择一个html文件作为模板 template: './index.html', // 在打包好的bundle.js后面添加hash hash: true &#125;) ]&#125; module内的rules是创建模块时，匹配请求的规则数组，里面是对不同类型文件的处理方式，即对什么类型的文件使用什么loader，test用来匹配文件，use是使用的loader，可以多个loader同时生效，顺序从右向左。这里loader有多种写法，比较灵活： 123456789101112131415161718192021222324252627module: &#123; rules: [ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;, &#123; test: /\.css$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; ... &#125; &#125; ] &#125;, &#123; test: /\.css$/, loader: 'style-loader', options: &#123; ... &#125; &#125; ] &#125;, 单个laoder可以直接写出来，多个loader可以使用use方法，同时也可以根据是否有options选项来决定怎么写。 这些搞定后，运行npm run build，使用浏览器打开dist/index.html，切到控制台，可以看到样式以&lt;style&gt;...&lt;/style&gt;形式引入了： 接下来我们再来个less示例，在src-&gt;css文件夹内新建style.less文件，里面随便写点样式，在src/index.js内通过import ‘./css/style.less’引入，同时安装less-loader来解析.less文件： 1npm i less less-loader -D 接下来编写rule，这里要主要loader的顺序，需要先使用less-loader解析.less样式： 123456789101112module: &#123; rules: [ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;, &#123; test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125; ] &#125;, 运行npm run build，来浏览器里看看结果： 看到我们的.less文件也引入到了页面中。 拆分css上面的样式都是通过&lt;style&gt;标签引入的，如果想以样式文件的方式引入，就需要用到extract-text-webpack-plugin插件，这里要注意，到目前为止，该插件的稳定版还不支持webpack4.0，需要安装它的beta版： 1npm i extract-text-webpack-plugin@next -D 引入插件： 123456789101112131415161718192021222324252627282930313233343536const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: "[chunkhash].bundle.js" &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: ExtractTextPlugin.extract(&#123; // 将css用link的方式引入就不再需要style-loader了 use: 'css-loader' &#125;), &#125;, &#123; test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; // 选择一个html文件作为模板 template: './index.html', // 在打包好的bundle.js后面添加hash hash: true &#125;), // 拆分后会把css文件放到dist目录下的css/style.css new ExtractTextPlugin('css/reset.css') ]&#125; 运行npm run build，看看dist内生成的文件，再看看浏览器： .less没有拆分，故还是以标签的形式引入页面。当然我们也可以同时拆分成多个css： 123456789101112131415161718192021222324252627// 正常写入的lesslet styleLess = new ExtractTextWebpackPlugin('css/style.css');// resetlet resetCss = new ExtractTextWebpackPlugin('css/reset.css');module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, use: resetCss.extract(&#123; use: 'css-loader' &#125;) &#125;, &#123; test: /\.less$/, use: styleLess.extract(&#123; use: 'css-loader' &#125;) &#125; ] &#125;, plugins: [ styleLess, resetCss ]&#125; 未完待续。。。]]></content>
      <tags>
        <tag>随写</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT中关于换行符CRLF和LF的探究]]></title>
    <url>%2F2018%2F07%2F10%2FGIT%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%8D%A2%E8%A1%8C%E7%AC%A6CRLF%E5%92%8CLF%E7%9A%84%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[平时在使用hexo写博客，提交发布的时候，总会在命令行报warning，大量的CRLF、LF、CR等字眼，而在使用WebStorm开发项目时，右下角除了编码模式，分支切换，行号等提示外，总会不经意间扫到CRLF的配置，点开看看还有LF - Unix and OS X(\n)和CR - CLassic Mac(\r)这样的配置项。本来以为是键盘按键的设置（win 和 mac有几个键不一样），今天随手一搜，发现原来是另外一回事儿，花半小时简单总结一下，写篇小博客。 背景CR(Carriage Return)代表的是回车，使用\r来表示；LF（Line Feed）代表换行，使用\n来表示，由于历史的原因，各操作系统的文本换行符号是不一致的，windows系统使用CRLF，即\r\n来表示换行，Uninx和近些年的OS X使用LF，即\n来表示换行，更早的Mac系统则使用CR，即\r来表示换行，不过这系统现在已经很少人用了。 现在问题来了，多人协作开发时，不可能保证每个人使用的系统一致，这就会导致换行编码的不同，虽然说“换行”在人眼看来没有区别，但是git面前可就不一样了，在推拉代码的过程中，如果换行符不一样，我是给你显示文件有修改呢还是直接默认没有任何更改？ 好在git提供了一个“换行符自动转换”功能帮我们处理了这个问题。默认情况下，git在远程仓库保存代码使用Unix风格，即换行符统一使用LF模式（\n），在推-拉代码的过程中，则有以下的规则： 提交代码时，git会将文本文件中的换行符转换为LF模式，这个过程也叫标准化过程； 拉取代码时，git会将试图将仓库中的代码转换为CRLF模式，这个过程也叫转换； 通过这样的拉-推自动转换，git不仅保持了远程仓库代码的一致性（Unix风格），而且保证了本地文件的兼容性（Windows系统）。 GIT个性化配置既然有默认配置，那就有个性化的选择，git提供了core.autocrlf和core.safecrlf两个配置项来供开发者自由配置。两者都支持全局、本地设置。 12345git config --global core.autocrlf [true | input | false] #全局设置git config --local core.autocrlf [true | input | false] #针对本项目设置git config --global core.safecrlf [true | warn | false] #全局设置git config --local core.safecrlf [true | warn | false] #针对本项目设置 core.autocrlfcore.autocrlf有三个值，默认是 true。这个配置用来决定要不要转换，怎么转换。 12345678// 默认设置，拉取时转换为CRLF，提交时转换为LFgit config --global core.autocrlf true// 拉取时不转换，提交时转换为LFgit config --global core.autocrlf input// 拉取时不转换，提交时也不转换git config --global core.autocrlf false core.safecrlfcore.safecrlf也有三个值，默认是 false。这个配置用来决定add代码时是否禁止提交混合换行符的文本文件。 12345678// 禁止提交混合换行符的文本文件(git add 的时候会被拦截，提示异常)git config --global core.safecrlf true// 提交混合换行符的文本文件的时候发出警告，但是不会阻止 git add 操作git config --global core.safecrlf warn// 默认配置，不禁止提交混合换行符的文本文件git config --global core.safecrlf false 延深知识上面的两个配置文件都是个人在本机的个性化设置，如果对于比较大的项目，多人协作的情况下不可能让每个人都去更改一下自己的配置，这个时候我们就可以在项目的根目录下添加一个.gitattributes文件，它的优先级高于core.autocrlf配置，它类似于 .gitignore 文件，随提交修改生效，一个项目中可以维持一份相同的配置。 当然，.gitattributes文件可不只有配置换行符，还有一些其他的复杂配置。 具体更深入的了解就等以后遇到了再去探究吧。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>知识积累</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的事件循环]]></title>
    <url>%2F2018%2F07%2F08%2FJavaScript%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[作为前端，提起JS，都知道它是一门单线程的语言，只能从上到下顺序执行JS任务，而任务又分为同步任务和异步任务，常见的如Ajax请求、setTimeout、setInterval、点击事件的回调函数等等都是异步任务。当我们的JS逻辑写的越来越复杂，可能会发现一些逻辑的执行顺序跟我们预想的不一样，或者压根就没执行，这时候深入理解一下JS中事件循环的逻辑就显得势在必行了，更不用提现今前端框架如此流行，弄清了事件循环机制，才能对框架的生命周期，数据更新策略等有更深入的理解。 写在前面浏览器是多进程的（注意不是线程），这里面包括Browser进程（主进程）、第三方插件进程、GPU进程和浏览器渲染进程，而渲染进程又称为浏览器内核，这个就跟我们前端有比较大的联系了。当我们在浏览器中每开一个tab页面，就相当于起了一个新的进程，该页面的渲染、js执行、事件的执行都是在这一个进程内。而每个渲染进程内可以包含多个线程，主要有：GUI渲染线程、JS引擎线程、事件触发线程、定时器触发线程、异步请求线程等。其中，GUI渲染线程和JS引擎线程是互斥的，两者同时只能有一个在运行，这就是为什么常说JS的执行会卡住页面，影响页面渲染（JS可能会操作dom元素）。说了这些，其实还没涉及到今天的主角，而浏览器的进程机制又是一些更深入的知识点了，今天不展开（也展不开，还没弄明白），下面我们进入今天的主角，JS事件循环。 事件循环这部分我们来搞清楚什么是一个完整的事件循环？每一个循环内的任务执行顺序是怎样的？下一次循环中的任务从哪里来？ 首先，JS分为同步任务和异步任务，同步任务在主线程上进行，形成一个执行栈，异步任务进入Event Table并注册函数，将注册函数（回调函数）放入到Event Queue事件队列中，供下一次循环来取用。如下思维图： 当执行栈内的任务执行完毕（执行栈为空），系统就会去Event Queue中读取最顶部的异步任务，添加到执行栈中进行执行。JS引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 我们结合一个例子来看： 12345console.log('1');setTimeout(() =&gt; &#123; console.log('2'); &#125;, 2000);console.log('3'); 执行顺序： 整段scripts开始执行，首先同步执行console.log(&#39;1&#39;)； setTimeout作为异步任务，进入Event Table，2s后将console.log(&#39;2&#39;)放进事件队列，待执行； 执行console.log(&#39;3&#39;)，接下来看有没有微任务（下面马上讲），没有，第一次事件循环结束； 执行栈为空，从Event Queue中将console.log(&#39;2&#39;)（宏任务）取过来，放到执行栈内执行，第二次事件循环结束； 执行栈再次为空，Event Queue内没有其他任务，等待下一次检查… setTimeout是作为异步任务进入到Event Table中的，所以即使说setTimeout(fn, 0)也是进入到Event Table中，等下一次循环再执行fn，不会立即执行。而且这样写的意思是一旦执行栈为空，就将回调fn置入主线程，无需等待，但根据HTML的标准，最低是4毫秒，也达不到0ms。 写到这里，我们还明白了为什么有时候明明写的延迟3s执行的fn却没有按时执行，那就是因为3s后虽然fn已经到了Event Queue中，但是执行栈并没有空下来，必须等到执行栈为空，才能将fn取出来放到执行栈去执行，这也是为什么进程内要单独开一个定时器触发线程来处理这类倒计时事件，这样才能保证延迟时间的准确性。 宏任务（macrotask）宏任务主要包括主代码块，setTimeout、setInterval等，浏览器为了能够使得JS内部事件循环与DOM任务能够有序的执行，会在一个事件循环结束后，在下一个 task 执行开始前，对页面进行重新渲染 （task-&gt;渲染-&gt;task-&gt;…） ，setTimeout的作用是等待给定的时间后为它的回调产生一个新的宏任务。 微任务（microtask）微任务主要包括promise.then()，process.nextTick，mutation observe的回调等。微任务会在这一次事件循环中的宏任务执行完成后执行，比如对一系列动作做出反馈，或或者是需要异步的执行任务而又不需要分配一个新的 task，这样便可以减小一点性能的开销。只要执行栈中没有其他的js代码正在执行且每个宏任务执行完，微任务队列会立即执行。如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行。 简单总结下，宏任务（macrotask）事件都被放到了一个事件队列（Event Queue）中，这个队列由事件触发线程维护；微任务（microtask）事件放到了微任务队列（Job Queues）中，等待宏任务（在当前事件循环）执行完成后执行，这个队列由JS引擎线程维护。 总结下运行机制： 执行一个宏任务（没有的话就去事件队列中取一个任务） 执行过程中遇到异步任务（setTimeout,ajax），走Event Table-Event Queue流程 执行过程中遇到微任务，就先将微任务添加到微任务队列中 宏任务执行完毕后，立即执行当前循环中微任务队列里所有的微任务（按添加顺序依次执行） 当前事件循环执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS引擎线程继续接管，开始下一个宏任务（从事件队列中取） 来看几个例子： 123456789101112console.log('1');setTimeout(function() &#123; console.log('setTimeout');&#125;)new Promise(function(resolve) &#123; console.log('promise');&#125;).then(function() &#123; console.log('then');&#125;)console.log('2'); 分析： 代码块作为宏任务，进入进程栈，执行console.log(&#39;1&#39;)； 遇到setTimeout，将其回调函数注册后分发到Event Queue（宏任务），等待下一次事件循环取用； 遇到promise，注意，这里直接执行console.log(&#39;promise&#39;)，而.then()回调被分发到了该次循环的Job Queue（微任务），等待执行； 遇到console.log(&#39;2&#39;)，打印； 该次循环宏任务执行完毕，然后在微任务列表发现了console.log(&#39;then&#39;)，执行； 第一次事件循环执行完毕，进程栈为空，开始去Event Queue拉取任务，进行第二次事件循环，console.log(&#39;setTimeout&#39;)进入进程栈，执行，第二次事件循环宏任务执行完毕，没有微任务，循环结束。 所以打印顺序为&#39;1&#39;-&gt;&#39;promise&#39;-&gt;&#39;2&#39;-&gt;&#39;then&#39;-&gt;&#39;setTimeout&#39;； 再来看一个复杂的例子： 123456789101112131415161718192021222324252627282930313233343536console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6');&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;) 分析： 首先整段scripts作为宏任务进入第一次事件循环，执行console.log(&#39;1&#39;)。 遇到setTimeout，将其回调函数注册后分发到Event Queue（宏任务），等待下一次事件循环取用。 遇到微任务process.nextTick，将其放入第一次事件的微任务队列。 遇到promise，直接执行console.log(&#39;7&#39;)，.then()回调作为微任务被放入微任务队列。 又遇到setTimeout，不管，将其回调函数注册后分发到Event Queue（宏任务），等待取用，注意这时候事件队列Event Queue已有两个宏任务。 第一次事件循环的宏任务执行完毕，开始执行微任务列表，依次执行console.log(&#39;6&#39;)、console.log(&#39;8&#39;)，微任务执行完毕，第一次事件循环结束，所以第一次事件循环执行过程：&#39;1&#39;-&gt;&#39;7&#39;-&gt;&#39;6&#39;-&gt;&#39;8&#39;。 进程栈为空，开始从事件队列拉取任务，首先取出来第一个任务，作为宏任务进入第二次事件循环。 先遇到console.log(&#39;2&#39;)，直接执行。 接着遇到微任务process.nextTick，将其放入第二次事件的微任务队列。 遇到promise，直接执行console.log(&#39;4&#39;)，.then()回调作为微任务被放入微任务队列。 第二次循环宏任务执行完毕，开始执行微任务队列任务，依次执行console.log(&#39;3&#39;)、console.log(&#39;5&#39;)，微任务执行完毕，第二次事件循环结束，所以第二次事件循环执行过程：&#39;2&#39;-&gt;&#39;4&#39;-&gt;&#39;3&#39;-&gt;&#39;5&#39;。 进程栈为空，继续从事件队列拉取任务，取出下一个任务，作为宏任务进入第三次事件循环。 先遇到console.log(&#39;9&#39;)，直接执行。 接着遇到微任务process.nextTick，将其放入第三次事件的微任务队列。 遇到promise，直接执行console.log(&#39;11&#39;)，.then()回调作为微任务被放入微任务队列。 第三次循环宏任务执行完毕，开始执行微任务队列任务，依次执行console.log(&#39;10&#39;)、console.log(&#39;12&#39;)，微任务执行完毕，第二次事件循环结束，所以第二次事件循环执行过程：&#39;9&#39;-&gt;&#39;11&#39;-&gt;&#39;10&#39;-&gt;&#39;12&#39;。 整个事件循环结束。 说到这里，基本上我们对事件循环就有了一个比较清晰的了解，当然更复杂的情况下就需要我们抽丝剥茧一点一点分析，再查阅更详细的资料去理解了，下面有两个比较复杂的demo，是从外文文章里找到的，有兴趣可以看一下，具体地址在文章末尾。 进阶Demo示例1： 123&lt;div class="outer"&gt; &lt;div class="inner"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930// Let's get hold of those elementsvar outer = document.querySelector('.outer');var inner = document.querySelector('.inner');// Let's listen for attribute changes on the// outer elementnew MutationObserver(function() &#123; console.log('mutate');&#125;).observe(outer, &#123; attributes: true&#125;);// Here's a click listener…function onClick() &#123; console.log('click'); setTimeout(function() &#123; console.log('timeout'); &#125;, 0); Promise.resolve().then(function() &#123; console.log('promise'); &#125;); outer.setAttribute('data-random', Math.random());&#125;// …which we'll attach to both elementsinner.addEventListener('click', onClick);outer.addEventListener('click', onClick); 当点击内层innerdiv块时： 因为冒泡，会将outer的点击事件放入到事件队列Event Queue，等待取用执行； 进程栈（JS stack）执行onClick()函数，直接打印console.log(&#39;click&#39;)； 接下来遇到setTimeout，将其回调注册到Event Queue，等待取用执行； 遇到微任务promise.then()，放入微任务队列； 接下来的MutationObserver也是微任务，放入微任务队列； 宏任务执行完，依次执行微任务，本次循环结束，打印顺序：&#39;click&#39;-&gt;&#39;promise&#39;-&gt;&#39;mutate&#39;； 接下来从事件队列中取第二次点击事件任务，再次执行2-6； 此时进程栈为空，事件队列里还有两次的setTimeout回调事件，依次执行，完毕； 打印顺序：&#39;click&#39;-&gt;&#39;promise&#39;-&gt;&#39;mutate&#39;-&gt;&#39;click&#39;-&gt;&#39;promise&#39;-&gt;&#39;mutate&#39;-&gt;&#39;timeout&#39;-&gt;&#39;timeout&#39;； 示例2： 123&lt;div class="outer"&gt; &lt;div class="inner"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132// Let's get hold of those elementsvar outer = document.querySelector('.outer');var inner = document.querySelector('.inner');// Let's listen for attribute changes on the// outer elementnew MutationObserver(function() &#123; console.log('mutate');&#125;).observe(outer, &#123; attributes: true&#125;);// Here's a click listener…function onClick() &#123; console.log('click'); setTimeout(function() &#123; console.log('timeout'); &#125;, 0); Promise.resolve().then(function() &#123; console.log('promise'); &#125;); outer.setAttribute('data-random', Math.random());&#125;// …which we'll attach to both elementsinner.addEventListener('click', onClick);outer.addEventListener('click', onClick);inner.click(); 示例2跟示例1基本一样，只有一点不同：示例2最后多了一行inner.click()，通过脚本来执行点击事件。这个就不分析了，可以去看Tasks, microtasks, queues and schedules，里面有详细的步骤动画，一步步分析。 参考链接：这一次，彻底弄懂 JavaScript 执行机制，从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理，译文：JS事件循环机制（event loop）之宏任务、微任务。本文图片和例子很多都来自于此，多谢各位牛人的分享，受益匪浅。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>知识积累</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由-0与NaN的判断来看Array的元素识别]]></title>
    <url>%2F2018%2F06%2F15%2F%E7%94%B1-0%E4%B8%8ENaN%E7%9A%84%E5%88%A4%E6%96%AD%E6%9D%A5%E7%9C%8BArray%E7%9A%84%E5%85%83%E7%B4%A0%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[今天无聊在翻看MDN开发文档时，看到这么一个方法Array.prototype.includes()，之前在书上看到过，说是ES6修订文档（可以称为ES7）中新增的一个方法，用来判断一个数组中是否包含一个指定的值，返回一个布尔类型。当时也没有深究新增的这个方法与Array.prototype.indexOf()到底有什么不同，闲来无事，深究了一下，结果扯出来一些关于值判断的问题，自己都把自己问蒙了。下面就简单总结一下。 先说两个方法： Array.prototype.includes(searchElement, fromIndex)用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false，fromIndex 表示从该索引处开始查找，如果为负数，则按升序从arr.length+fromIndex的索引开始搜索。默认为0。 12345var arr = [1, 2, 3, NaN, 0, -0];console.log(arr.includes(1)); //trueconsole.log(arr.includes(NaN)); //trueconsole.log(arr.includes(3, 3)); //falseconsole.log(arr.includes(2, -2)); //false Object.is(value1, value2)用来判断两个值是否相等，返回布尔值，下面情况则认为是相等的： 两个值都是undefined 两个值都是null 两个值都是true或false 两个值是由相同个数的字符按照相同的顺序组成的字符串 两个值指向同一个对象 两个值都是数字并且都是正零+0、都是负-0、都是NaN、都是除零和NaN外的其他同一个数字 1234Object.is(undefined, undefined); //trueObject.is(null, null); //trueObject.is(0, -0); //falseObject.is(NaN, NaN); //true 从上面可以看出，Object.is()与全等===不同的地方在于，===认为正零+0和负零-0相等，而且NaN不自等： 12console.log(0 === -0); // trueconsole.log(NaN === NaN); // false includes VS indexOf以往我们在判断某一项是否存在于一个数组内时，都是使用arr.indexOf(item)方法，根据返回的索引值是否为-1来进行判断： 12345678910var arr = [1, 2, 3, 4, 0, -0, NaN];if (arr.indexOf(5) &gt; -1) &#123; //不会执行&#125;if (arr.indexOf(NaN) &gt; -1) &#123; //不会执行&#125;console.log(arr.indexOf(NaN)); // -1console.log(arr.indexOf(-0)); // 4console.log(arr.indexOf(0)); // 4 方法可行，但是这种方法一来无法判断NaN，另一方面既然我们在条件判断语句中使用，为什么不能有一个返回布尔类型的方法呢？includes()方法应运而生。 12345678910var arr = [1, 2, 3, 4, 0, NaN];if (arr.includes(5)) &#123; //不会执行&#125;if (arr.includes(NaN)) &#123; //执行&#125;console.log(arr.includes(NaN)); //trueconsole.log(arr.includes(4)); //trueconsole.log(arr.includes(-0)); //true，与indexOf一样，都无法区分+0和-0 这样我们在进行元素存在判断的时候就不用再跟-1去比较了，直接返回布尔值，岂不美哉！ Object.is() VS ===除了值‘在不在’的判断，我们日常还会跟值‘等不等’来打交道。现在随便问个Front-Ender都知道使用全等===来进行‘等不等’的判断，当然这里就涉及到我之前博客里讲的隐式类型转换的知识了，不再重复。如果我要判读的值是NaN或者-0呢？全等===还能胜任吗？ 12console.log(NaN === NaN); // false, 都知道NaN‘不自等’console.log(0 === -0); // true, 无法区分+0和-0 有个小误区，其实NaN应该跟NaN相等才是正常的，长久以来，一直被NaN不自等所误导，反而认为NaN不相等。现在有了Object.is()，可以愉快的判断NaN和-0了： 123console.log(Object.is(NaN, NaN)); // trueconsole.log(Object.is(0, -0)); // falseconsole.log(Object.is(-0, -0)); // true 还有一种粗暴的方式来判断-0： 12345678var x = -0;if (x == 0 &amp;&amp; 1 / x === -Infinity) &#123; // -0的情况&#125;//或者if (x == 0 &amp;&amp; 1 / x &lt; 0) &#123; // -0的情况&#125; Number.isNaN() VS isNaN()说起NaN的判断，怎么能不提isNaN()和Number.isNaN()，Number.isNaN()是一个更强大的方法，该方法不会强制将参数转换为数字，只有在参数是真正的数字类型，并且值为NaN的时候才会返回true。 1234567Number.isNaN(NaN); // trueNumber.isNaN(0 / 0); // trueNumber.isNaN('NaN'); // trueNumber.isNaN(&#123;&#125;); // falseNumber.isNaN(undefined); // falseNumber.isNaN('test'); // falseNumber.isNaN('37'); // fasle 而isNaN()会首先尝试将这个参数转换为数值，然后才会对转换后的结果是否是NaN进行判断。 对于能被强制转换为有效的非NaN数值来说（空字符串和布尔值分别会被强制转换为数值0和1），返回false值也许会让人感觉莫名其妙。 1234567isNaN(''); // falseisNaN(true); // falseisNaN('NaN'); // trueisNaN(&#123;&#125;); // trueisNaN(undefined); // trueisNaN('test'); // trueisNaN('37'); // false 其实这里面又涉及到了类型转换的问题，可以看一下之前的博客。 总结 当需要判断数组内是否有NaN时，可以考虑使用includes()方法，当然要考虑兼容性问题； 当需要判断一个值是否是NaN时，可以使用Object.is()和Number.isNaN()，优先使用Number.isNaN()； 如果非要考虑-0的情况，那就可以使用Object.is()或者x == 0 &amp;&amp; 1 / x &lt; 0来进行判断；]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>知识积累</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE双向数据绑定原理及简单实现]]></title>
    <url>%2F2018%2F06%2F03%2FVUE%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Reactive Programming是一种编程形式，在很多场景都会见到，最近正在学习的RxJS是一个例子，当然Vue同样是一种Reactive Programming，就是当变量发生改变的时候，相关的变量和视图也会跟着改变，而我们开发者不需要自己去写代码来实现这个过程，我们只需要关心变量改变之后应该进行什么操作，更加关注于业务流程。 Vue的双向数据绑定是基于ES5的Object.defineProperty()的getter和setter，每当数据发生变化，就会执行getter/setter，结合发布者/订阅者的模式，通知订阅者这些变化，进而执行相应的回调函数。 今天我们来分析一下vue双向数据绑定的原理，同时我们自己用js来实现一个简单的双向数据绑定，首先看一下原理图： MVVM就是我们要实现的vue实例，简单讲述一下流程： 首先通过一个Observer（监听器或者劫持器）去劫持data对象中的所有属性，方法就是使用Object.defineProperty()中的getter/setter，在属性set的时候通知Dependency（订阅器/容器）发布变化； 实现一个Watcher（订阅者），这个Watcher就是说我收到数据变化的通知后，应该去执行什么操作（重新填充列表，填充值等等，即更新视图），一个data.message数据可能对应多个使用场景，比如v-model=&quot;message&quot;、v-text=&quot;message&quot;、{ {message} }等等，所以Watcher不止一个； 上面说到Watcher不止一个，所以我们可以实现一个容器Dependency，里面存放data.message对应的所有Watcher，这样当Observer的Setter改变时，调用Dependency的notify方法，逐条去通知所有的Watcher； 实现一个编译器Complier，编译器的作用是扫描和解析每一个节点node，先将节点转换为fragment（性能优化，一次性append所有节点至目标element内），再根据不同的节点类型nodeType，针对v-model、v-text、做不同的处理，完成第一次的数据message填充（即初始化视图）；同时编译器还担当着初始化Watcher的任务，将Watcher添加到Dependency中去； 有了以上的思路，接下来就是编写代码时间，使用了ES6的class，首先我们来实现Observer: 12345678910111213141516171819202122232425262728293031323334353637class Observer &#123; constructor(data) &#123; this.observer(data); &#125; observer(data) &#123; if (!data || typeof data !== 'object') &#123; return false; &#125; else &#123; Object.keys(data).forEach((key) =&gt; &#123; // 劫持data对象中的每一条数据 this.defineReactive(data, key, data[key]); &#125;) &#125; &#125; defineReactive(obj, key, value) &#123; let dep = new Dependency(); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: false, get() &#123; if (Dependency.target) &#123; dep.addSub(Dependency.target); // 添加订阅者watcher,应该是整个实例Watcher &#125; return value; &#125;, set(newValue) &#123; // 值未变化return回去 if (newValue === value) &#123; return false; &#125; value = newValue; // 数据变化，通知dep里所有的watcher dep.notify(); &#125; &#125;) &#125;&#125; // 第一次get值的时候不会添加Watcher到Dependency,实例化（调用）watcher时再添加Dependency.target = null; 接下来实现Watcher: 1234567891011121314151617181920212223class Watcher &#123; constructor(vm, expr, callback) &#123; this.vm = vm; this.expr = expr; // data中的key值 this.callback = callback; // 值变化的时候执行什么回调 this.value = this.get(); // 实例化watcher的时候将自己添加到Dependency &#125; get() &#123; Dependency.target = this; // 缓存自己,就是这个Watcher实例 let value = this.vm.$data[this.expr]; // 触发执行Observer中的get函数，将自己添加到Dep Dependency.target = null; // 释放自己 return value; &#125; update() &#123; // 值更新后，Observer的setter就会触发，就会执行dep.notify()，即通过Dep容器通知watcher根据callback去更新视图 let newValue = this.vm.$data[this.expr]; let oldValue = this.value; if (newValue !== oldValue) &#123; // 新老值不一致，执行回调 this.callback(newValue); &#125; &#125;&#125; 然后我们需要一个容器Dependency去储存data.message对应的所有Watcher: 1234567891011121314class Dependency &#123; constructor() &#123; this.subs = []; // 容器数据，放watcher用 &#125; addSub(watch) &#123; this.subs.push(watch); // 将watcher添加到subs内 &#125; notify() &#123; // 通知subs内的所有watcher更新回调 this.subs.forEach((watch) =&gt; &#123; watch.update(); &#125;) &#125;&#125; 下面是编译器Complier，编译器涉及的东西比较杂，判断的情况比较多，所以这里只考虑到了v-model、v-text、{ {message} }这3种情况的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class Complier &#123; constructor(el, vm) &#123; this.vm = vm; this.el = document.querySelector(el); if (this.el) &#123; // 使用fragment储存元素，这时候#app内就没有节点了，因为已经被frag删除完了 let fragment = this.nodeToFragment(this.el); this.complie(fragment); // 编译fragment this.el.appendChild(fragment); // 将fragment放回#app内 &#125; &#125; complie(node) &#123; // 使用Array.from将类数组node.childNodes转换为真正的数组 let nodeList = Array.from(node.childNodes); nodeList.forEach((item) =&gt; &#123; //根据nodeType判读节点类型，执行不同的编译 switch (item.nodeType) &#123; case 1: this.elementComplier(item);break; case 3: this.textComplier(item);break; &#125; &#125;) &#125; elementComplier(node) &#123; // 元素节点编译器，处理属性v-model，v-text等 let attrs = Array.from(node.attributes); attrs.forEach((attr) =&gt; &#123; if (attr.name.indexOf('v-') &gt; -1) &#123; let type = attr.name.split('-')[1]; // 取到'model',即指令的类型 complierUnits[type] &amp;&amp; complierUnits[type](node, this.vm, attr.value); &#125; &#125;) &#125; textComplier(node) &#123; // 文本节点编译器&#123;&#123;message&#125;&#125;,跟v-text共用一个编译方法 if ((/\&#123;\&#123;(.+)\&#125;\&#125;/).test(node.textContent)) &#123; complierUnits.text(node, this.vm, RegExp.$1); &#125; &#125; nodeToFragment(node) &#123; // 将node转换为fragment let frag = document.createDocumentFragment(); let child; while (child = node.firstChild) &#123; // fragment调用appendChild方法会删除node.firstChild节点 frag.appendChild(child); &#125; return frag; &#125;&#125;// 编译器工具箱const complierUnits = &#123; model (node, vm, expr) &#123; let updateFn = this.updater.modelUpdater; // 初始化的时候取一次值填充，渲染页面数据 updateFn &amp;&amp; updateFn(node, vm.$data[expr]); // 实例化watcher(调用watcher),将watcher添加到Dep中，同时定义好回调函数（数据变化后干什么） new Watcher(vm, expr, function(newValue)&#123; updateFn &amp;&amp; updateFn(node, newValue); &#125;); // 监听input值的变化，从视图到data node.addEventListener('input', (event) =&gt; &#123; vm.$data[expr] = event.target.value; &#125;) &#125;, text (node, vm, expr) &#123; let updateFn = this.updater.textUpdater; updateFn &amp;&amp; updateFn(node, vm.$data[expr]); new Watcher(vm, expr, function(newValue)&#123; updateFn &amp;&amp; updateFn(node, newValue); &#125;); &#125;, updater: &#123; modelUpdater(node, value) &#123; node.value = value; &#125;, textUpdater(node, value) &#123; node.textContent = value; &#125; &#125;&#125;; 还有入口main.js: 12345678910111213class MVVM &#123; constructor(options) &#123; this.$el = options.el; this.$data = options.data; // 当视图存在时 if (this.$el) &#123; // 将属性添加进Observer，劫持数据 new Observer(this.$data); // 编译页面 new Complier(this.$el, this); &#125; &#125;&#125; 最后就是html调用了： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;vue原理简单实现&lt;/title&gt; &lt;script src="js/dependency.js"&gt;&lt;/script&gt; &lt;script src="js/observer.js"&gt;&lt;/script&gt; &lt;script src="js/watcher.js"&gt;&lt;/script&gt; &lt;script src="js/complier.js"&gt;&lt;/script&gt; &lt;script src="js/main.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;span v-text="message"&gt;&lt;/span&gt; &lt;input type="text" v-model="message" /&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script&gt; let vm = new MVVM(&#123; el: '#app', data: &#123; message: 'hello Vue!' &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 总结：实例化MVVM时，先使用Object.defineProperty劫持每一个data数据，为每一个属性实例化一个Dependency；在编译页面的时候为每一个需要更新message的地方添加一个Watcher，即v-model=&quot;message&quot;、v-text=&quot;message&quot;和{ {message} }，有一个算一个，将这些Watcher添加到Dependency中进行统一管理；在编译的时候我们还要为input添加一个事件监听addEventListener，这样input的输入值变化时，触发setter，在setter内调用Dep的notify()方法，循环调用每一个Watcher的update更新我们的视图（执行回调函数）。 以上代码都放到了我的github仓库vue-principle，欢迎查阅。 参考文章：vue双向绑定原理分析，vue的双向绑定原理及实现]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《offset、scroll、client知识总结》]]></title>
    <url>%2F2018%2F04%2F25%2F%E3%80%8Aoffset%E3%80%81scroll%E3%80%81client%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E3%80%8B%2F</url>
    <content type="text"><![CDATA[获取元素位置，滚动高度，实现懒加载效果等等与元素位置有关的问题时，总绕不开scrollTop、scrollWidth、offsetTop等等属性名词，有的时候只用到某几个属性，但是没有通盘总结了解一下这几个看起来相似的属性，今天就来总结一下，顺带感受一下灵魂画师的绘画技巧… 偏移量offset与偏移量有关的四个属性是：offsetHeight、offsetWidth、offsetTop和offsetLeft，先上个图简单指示一下：灵魂画手，使用ipad备忘录画的。以上可以清楚的看到这四个offset属性各指什么，可以将偏移量offset理解为“元素块”，offset就是指元素的实际大小，包括边框，包括滚动条（如果窗口不够大，出现scrollBar）,而且这个大小跟是否有隐藏的部分是无关的，实际多大，offsetWidth和offsetHeight就是指多大。另外，offsetTop和offsetLeft指的是元素块的外边框跟它外出元素块的内边框间的距离。有时候还有 客户区client与客户区有关的四个属性是：clientWidth、clientHeight、clientTop和clientLeft，上个图简单指示一下：需要注意的是，clientWidth和clientHeight均不包含滚动条的宽度，同时也跟是否有隐藏的部分无关，实际多大的窗口，就是多大（没有scrollBar）；而且，所谓的clientTop和clientLeft就是指元素对应的border大小。 滚动区scroll与客户区有关的四个属性是：scrollWidth、scrollHeight、scrollTop和scrollLeft，上个图简单指示一下：滚动的scrollWidth和scrollHeight也是不包括滚动条的，scrollTop和scrollLeft也分别如图所示。 网上还流传着一张更复杂的图，一并放到这里作参考：]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>知识积累</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《DOM知识点总结》]]></title>
    <url>%2F2018%2F04%2F17%2F%E3%80%8ADOM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E3%80%8B%2F</url>
    <content type="text"><![CDATA[DOM(文档对象模型)是针对HTML和XML文档的一个API，描绘了一个层次化的节点树，允许我们添加、移除和修改页面的某一部分。目前流行的各种前端框架，对于页面结构的调整更新构建都是基于DOM的原生API来实现的，而我们平时在进行前端开发时也或多或少会用到DOM原生操作，尤其是“抛弃”jQuery这个框架之后，原生的DOM操作越来越重要，今天就来总结一些常见的DOM属性和操作方法。 Node类型DOM将文档描绘成了一个多层次节点构成的结构，节点有很多的类型，每个类型又有不同的特点、数据和方法，节点之间也存在着相互的关系，同级关系，子父级关系等等。整个文档就是由一个个节点构建起来的树，就是我们经常说的DOM树。每个节点（node）都有一个nodeType属性，表明节点的类型，下面先简单列举一下常见的节点类型： Node.ELEMENT_NODE(1)———–元素节点，nodeType值为1 Node.ATTRIBUTE_NODE(2)———属性节点，nodeType值为2 Node.TEXT_NODE(3)————–文本节点，nodeType值为3 Node.COMMENT_NODE(8)———–注释节点，nodeType值为8 Node.DOCUMENT_NODE(9)———-文档节点，nodeType值为9 Node.DOCUMENT_TYPE_NODE(10)—-doctype节点，nodeType值为10 可以通过节点的nodeType值来判断节点类型123if(someNode.nodeType == 1)&#123; console.log("Node is an element.")&#125; 节点关系节点之间存在着这样或那样的关系，每个node都有一个childNodes属性，其中保存着一个NodeList对象，有length属性，但不是一个Array实例，可以像下面一样访问里面存着的node:123var fistChild = someNode.childNodes[0];var secondChild = someNode.childNodes.item(1);var count = someNode.childNodes.length; 还有一些属性： someNode.nextSibling 同级下一个节点 someNode.previousSibling 同级前一个节点 someNode.firstChild 节点的第一个子节点 someNode.lastChild 节点的最后一个子节点 someNode.parentNode 节点的父节点 节点操作方法常见的操作方法 someNode.appendChild(newNode)————–在节点的childNodes末尾添加一个新节点，返回new someNode.insertBefore(newNode, whoNode)—-在who前面添加一个new节点，返回new someNode.replaceChild(newNode, whoNode)—-将who替换为new节点，返回who someNode.removeChild(whoNode)————–将who移除，返回who 以上方法都是在父节点上的操作，没有子节点节点调用这些方法会报错。 两个特例方法这俩方法有没有子节点都可以使用： cloneNode()这个方法用来复制调用它的节点，可以传一个参数true来进行深复制；12345//浅复制，只复制节点本身，不会复制节点内部var copyNode = someNode.cloneNode(false);//深复制，复制节点内部子节点var deepCopy = someNode.cloneNode(true); 要注意的一点是，cloneNode的默认参数在不同的规范下，取true和false都有可能，建议强制写明参数，不使用默认值（其实也不知道默认值到底是啥）。 normalize()这个方法是文本节点(Text_Node)的专用方法，在someNode上调用时，如果在其后代节点找到了空文本节点，就删除这个空文本节点；如果找到了相邻的文本节点（一般来说直接写的html都只有一个文本节点，除非我们用createTextNode()这种方法创建文本节点，才有可能出现相邻的文本节点），则合并为一个节点。 元素节点ELement_Node其实元素节点简单来说就是html中的标签，什么p标签，h1标签等等，先说一下它的特性： nodeType值为1； nodeName值为元素标签名；也可以使用tagName获取，注意大小写问题 nodeValue值为null；它也没啥值好用的 parentNode可能为Document或Element；文档的子节点或者其他element的子节点 子节点可能是：Element、Text、Comment等等； HTML元素所有的HTML元素都是由HTMLElement类型表示，它就是继承自Element，然后添加了一些属性，其实感觉跟ELement一个东西，主要有以下属性： id;————就是div的id么，标识符一个 title;———就是那个title lang和dir;—–很少用 className;—–class的名字结合 其中className属性，这个注意一下，返回的是一个class名称的字符串合集，比如”item active test”，需要自己用字符串方法拆分操作它，后来HTML5就新增了一个classList属性，返回的是个class数组，比[‘item’, ‘active’, ‘test’]，可以用数组的方式操作class名称，就很方便了。 classList属性有自己的几个操作方法： add(value);———-将给定的字符串添加到列表，如果有，则不添加 contains(value);—–列表里面有没有给定的值，返回true/false remove(value);——-删除列表中给定的值 toggle(value);——-没有就添加，有就删除 123div.classList.remove('item');div.classList.add('current');div.classList.toggle('active'); 操作特性操作div元素的属性，就是常见的几种方法，列举一下： getAttribute(); setAttribute(); removeAttribute(); 我们还经常自定义属性，比如在标签里定义个id=&#39;1&#39;，HTML5规范建议自定义属性加上data-前缀，表明是自定的属性，这样可以使用div.dataset.id取得属性值。还有一个Attributes属性，不展开说了，不怎么用到。 创建元素节点可以使用document.createElement()方法创建元素节点。再配合node的操作方法，进行各种穿插。 属性节点Attribute_Node属性节点不被认为是DOM文档树的一部分，简单说一下它的特性： nodeType值为2； nodeName值为特性的名称； nodeValue值为特性的值； parentNode为null 没有子节点 操作属性一般用上面的getAttribute()、setAttribute()、removeAttribute()。 文本节点Text_Node文本节点简单说就是标签里的内容，比如&lt;div&gt;hello world&lt;/div&gt;中的’hello world’，先说一下它的特性： nodeType值为3； nodeName值为#text; nodeValue值为节点包含的文本； parentNode可能Element； 没有子节点； 开始和结束标签之间只要有内容，就会创建一个文本节点：12345678910//没有文本节点&lt;div&gt;&lt;/div&gt;//有空格，故有一个文本节点&lt;div&gt; &lt;/div&gt;//有内容，故有一个文本节点&lt;div&gt;hello world&lt;/div&gt;var textNode = div.firstChild;textNode.nodeValue; // hello world 创建文本节点可以通过document.createTextNode(&#39;hello world&#39;)创建一个文本节点，再配合node的操作方法，进行各种穿插。一般来讲，一个元素只有一个文本节点，但是你要是硬搞几个相邻节点，也是可行的，然后就有了normalize()和spliteText()这俩方法：12345678910111213var element = document.createElement('div');element.className = 'message';var textNode = document.createTextNode('hello world');element.appendChild(textNode);var anotherTextNode = document.createTextNode('Yep!');element.appendChild(anotherTextNode); //这样就有了俩文本节点alert(element.childNodes.length); // 2element.normalize();alert(element.childNodes.length); // 1alert(element.firstChild.nodeValue); // 'hello worldYep!' spliteText()是将文本节点进行分割，具体细节不想讲了，碰见了再查。 文档节点Document_Node文档节点表示整个HTML页面，document对象也是window对象的一个属性，说一下它的特性： nodeType值为9； nodeName值为#document; nodeValue值为null； parentNode值为null； 子节点可能是一个DocumentType、Element、Comment； 子节点document的子节点也就是常见的html、head、body、doctype等，可以用下面的属性取得它们的引用：1234var html = document.documentElement;var head = document.head; // HTML5新定义的var body = document.body;var doctype = document.doctype; 文档信息仅做了解：123456var originTitle = document.title; // 取得页面的titledocument.title = 'New Title'; // 设置页面titlevar url = document.URL; // 取得页面的完整URLvar domin = document.domin; // 取得域名var referrer = document.referrer; // 取得来源页面的URL 查找元素document.getElementById()根据id获取元素的引用，如果找不到，就返回null，只能使用document调用。 getElementsByTagName()根据标签名获取一个HTMLCollection元素列表，跟NodeList对象类似。可以使用document或者element调用123456var images = document.getElementsByTagName('img'); // document调用images.length; // 数量images[0].src;images.item(0).src;var test = element.getElementsByTagName('a'); // element调用 还可以传入一个*来获取文档中的所有元素。 getElementsByClassName()根据class类名查找，可以使用document或者element调用12var test = document.getElementsByClassName("item active");var test1 = element.getElementsByClassName("item"); DOM的扩展DOM还有一个SelectorsAPI的扩展，另一个是HTML5，下面说一下SelectorsAPI，都可以通过element或者document调用。 querySelector()接受一个CSS选择符，返回匹配到的第一个元素，没有找到就返回null。12var body = document.querySelector('body');var myDiv = document.querySelector('#myDiv'); querySelectorAll()同样接受一个CSS选择符，返回一个NodeList实例。1234var ems = document.getElementById('myDiv').querySelectorAll('em');var strongs = document.querySelectorAll('p strong');strongs.item(1);strongs[2]; 文档写入 wirte(); wirteIn();—–跟write()一样，只不过会在写入的字符串最后添加一个’/n’ close(); open(); HTML5新增了innerHTML()和outerHTML()两个方法，不同的是outerHTML()会包含调用元素本身。另外一个需要了解的方法是contains()，用来判断某个节点是不是调用节点的子节点：1document.documentElement.contains(document.body); // true 本次先总结这些，下次我们来总结一下原生操作样式div.style.color和关于offsetWidth、scrollTop等的知识点。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>知识积累</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ES6总结之Map和Set》]]></title>
    <url>%2F2018%2F04%2F08%2F%E3%80%8AES6%E6%80%BB%E7%BB%93%E4%B9%8BMap%E5%92%8CSet%E3%80%8B%2F</url>
    <content type="text"><![CDATA[ES6新增了Map、Set两种新的数据结构，解决了Javascript中对象和数组结构的一些痛处：比如Map类似于对象结构，但是允许非字符串值作为键值，Set则类似于数组结构，但是不允许有重复的value，我们可以用这个特性来进行去重操作等等。这两种数据结构都有自己的一个变体：WeakMap和WeakSet，都涉及到GC（垃圾回收）机制的工作方式。总体而言，这两种数据结构都方便了我们对数据进行更优雅、更强大的操作，今天来总结一些两者的操作方法以及GC方面的相关知识。 MapMap数据结构类似于对象结构，但是允许非字符串来作为键值，也就是“值-值”的对应方式。 操作方法和属性12345678var m = new Map();var x = &#123; a: 1 &#125;, y = &#123; b: 2 &#125;;m.set( x, "foo" );m.set( y, "bar" );m.get(x); // "foo"m.get(y); // "bar" Map结构可以通过set(..)和get(..)方法来进行数据的添加和获取。另外还有has(..)、delete(..)、clear()来对Map进行操作：12345678m.size; // 2 返回map的长度m.has(x); // true 是否有x元素m.delete(x); // 删除x元素，返回布尔值，是否删除成功m.has(x); // falsem.clear(); //清空mapm.size; // 0 如果对map的一个键多次赋值，后面的将覆盖前面的：12m.set( x, "foo" ).set( x, "baz");m.get(x); // "baz" 注意，只有对同一对象的引用，Map结构才会将其视为同一键值：123var m = new Map();m.set( ['1'], "foo" );m.get( ['1'] ); // undefined 上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。其实，Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。 如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但Map将其视为同一个键。123456789101112131415let map = new Map();map.set(-0, 123);map.get(+0) // 123map.set(true, 1);map.set('true', 2);map.get(true) // 1map.set(undefined, 3);map.set(null, 4);map.get(undefined) // 3map.set(NaN, 123);map.get(NaN) // 123 我们还可以在Map(..)构造器中手动指定一个项目列表（键/值数组的数组）：12345678var x = &#123; a: 1 &#125;, y = &#123; b: 2 &#125;;var m = new Map([ [ x, "foo" ], [ y, "bar" ] ])m.get(x); // "foo"m.get(y); // "bar" 遍历方法Map结构原生提供三个遍历器生成函数和一个遍历方法： keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历Map的所有成员。 注意，Map的遍历顺序就是插入顺序，可以使用ES6的...扩展操作符将Map结构转为数组结构： 123456789101112131415161718var x = &#123; a: 1 &#125;, y = &#123; b: 2 &#125;;var m = new Map([ [ x, "foo" ], [ y, "bar" ] ])var vals = [...m.values()];console.log(vals); // ["foo", "bar"]var keys = [...m.keys()];console.log(keys); // [&#123;a:1&#125;, &#123;b:2&#125;]var entries = [...m.entries()];console.log(entries); // [ [&#123;a:1&#125;, "foo"], [&#123;b:2&#125;, "bar"]]entries[0][0]; // &#123;a:1&#125;entries[0][1]; // "foo"entries[1][0]; // &#123;b:2&#125;entries[1][1]; // "bar" Map的forEach方法，与数组的forEach方法类似，也可以实现遍历。123map.forEach(function(value, key, map) &#123; console.log("Key: %s, Value: %s", key, value);&#125;); 结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。1234567891011121314var map0 = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c');var map1 = new Map( [...map0].filter(([k, v]) =&gt; k &lt; 3));// 产生 Map 结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;var map2 = new Map( [...map0].map(([k, v]) =&gt; [k * 2, '_' + v]) );// 产生 Map 结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125; WeakMapWeakMap是Map的变体，二者的多数外部特性是一样的，主要有两点区别：首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。1234567var m = new WeakMap();map.set(1, 2)// TypeError: Invalid value used as weak map keymap.set(Symbol(), 2)// TypeError: Invalid value used as weak map keymap.set(null, 2)// TypeError: Invalid value used as weak map key 其次，WeakMap的键名所指向的对象，不计入垃圾回收机制，而且只弱持有键，而不弱持有值，如果键（这个对象）本身被GC，在WeakMap中的这个项目也会被移除；返过来，如果值被GC，则在WeakMap中的这个项目不会受到影响。1234567891011121314var m = new WeakMap();var x = &#123; id: 1 &#125;, y = &#123; id: 2 &#125;, z = &#123; id: 3 &#125;, w = &#123; id: 4 &#125;;m.set( x, y );x = null; // 将 变量x GCm.get(x); // undefined，项目x: y已经被GCm.set( z, w );w = null; // 将 变量w GCm.get(z); // &#123; id: 4 &#125; 未被GCm; // &#123; &#123;id: 3&#125;: &#123;id: 4&#125; &#125; 该项依旧存在 当我们需要释放某些对象所占用的内存，我们就必须手动删除这些引用，让垃圾回收机制释放内存，同时存在WeakMap内对应的项会自动消失，不用手动删除引用。所以如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。总之，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。另外，WeakMap没有size属性和clear()方法，也不存在遍历操作（key()、values()、entries()）。 SetSet数据结构类似于数组结构，但是其值唯一，重复值会被忽略。 操作方法和属性Set的API和Map类似，但没有get(..)方法，同时用add(..)方法替换了set(..)：12345678910111213var s = new Set();var x = &#123; id: 1 &#125;, y = &#123; id: 2 &#125;;s.add(x);s.add(y);s.add(x);s.size; // 2s.delete(y); // 删除是否成功的布尔值s.size; // 1s.has(x); // trues.clear();s.size; // 0 向Set加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值；Set内部判断两个值是否不同，使用的算法叫做Same-value-zero equality，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身；两个对象也总是不相等的。 1234567891011var s1 = new Set();var a = NaN, b = NaN;s1.add(a);s1.add(b);s1; // Set &#123;NaN&#125;var s2 = new Set();s2.add(&#123;&#125;);s2.size; // 1s2.add(&#123;&#125;);s2.size; // 2 遍历方法Set结构原生提供三个遍历器生成函数和一个遍历方法，与Map相同： keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历Set的所有成员。 Set结构没有键名，只有键值（或者说键名和键值是同一个值），而且Set的遍历顺序就是插入顺序，ES6的...扩展操作符也可以用于Set结构： 12345678910111213141516var s = new Set(['a', 'b', 'c']);var vals = [...s.values()];console.log(vals); // ['a', 'b', 'c']var keys = [...s.keys()];console.log(keys); // ['a', 'b', 'c']var entries = [...s.entries()];console.log(entries); // [ [ 'a', 'a' ], [ 'b', 'b' ], [ 'c', 'c' ] ]entries[0][0]; // 'a'entries[0][1]; // 'a'entries[1][0]; // 'b'entries[1][1]; // 'b'entries[2][0]; // 'c'entries[2][1]; // 'c' Set结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。12var s = new Set([1,2,3]);s.forEach((value, key) =&gt; console.log(key + ' : ' + value)); 同样，数组的map和filter方法也可以间接用于Set了：1234567var set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;var set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：&#123;2, 4&#125; 一个技巧，使用Set可以很容易地实现并集（Union）、交集（Intersect）和差集1234567891011121314var s1 = new Set([1, 2, 3]);var s2 = new Set([4, 3, 2]);// 并集let union = new Set([...s1, ...s2]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...s1].filter(x =&gt; s2.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...s1].filter(x =&gt; !s2.has(x)));// Set &#123;1&#125; WeakSetWeakSet是Set的变体，也是不重复的值的集合，主要有两点区别：首先，WeakSet的值也必须是对象，不能是其他类型的值；1234567var ss = new WeakSet();ss.add(1);// TypeError: Invalid value used as weak set keyss.add(Symbol());// TypeError: Invalid value used as weak set keyss.add(null);// TypeError: Invalid value used as weak set key 其次，WeakSet对于其内的对象，也是弱持有的，只要对象在外部消失，它在WeakSet里面的引用就会自动消失，由于这个特点，WeakSet的成员是不适合引用的，因为它会随时消失。另外，由于WeakSet内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此ES6规定WeakSet不可遍历。12345678var a = &#123; id: 1 &#125;, b = &#123; id: 2 &#125;;var s = new WeakSet();s.add(a);s.add(b);a = null; // a可以被GCb = null; // b可以被GC//注意，浏览器对于GC有一定的机制，此时访问s，可能内部还有值 还有一点注意，WeakSet只有has()、add()和delete()这3个操作方法，没有size属性和clear()方法。WeakSet也不能遍历，因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《this探究》]]></title>
    <url>%2F2018%2F03%2F31%2F%E3%80%8Athis%E6%8E%A2%E7%A9%B6%E3%80%8B%2F</url>
    <content type="text"><![CDATA[今天来对this这个JavaScript中很重要，有时候也会让很多人绕晕的关键字做一个总结。首先我们得明白this既不指向函数自身也不指向函数的词法作用域，它实际上是在函数被调用时发生的绑定，指向哪里完全取决于函数在哪里被调用。 this关键字绑定规则分析this的绑定规则时，我们要先找到函数的调用位置，再判断需要应用下面的哪条规则。 默认绑定默认绑定是最常见的一种，分为两种情况： 非严格模式下在非严格模式，函数的独立调用下，this指向全局对象。12345function foo()&#123; console.log(this.a);&#125;var a = 2;foo(); // 2 foo()是直接使用不带任何修饰的函数引用进行调用的，此时应用默认绑定，foo()中的this指向全局对象。 严格模式下在严格模式下，不能将this指向全局，因此this会被绑定到undefined。1234567funciton foo()&#123; "use strict"; console.log(this.a);&#125;var a = 2;foo(); // TypeError: this is undefined this指向了undefined，this.a会报错。这里需要注意的一点是，如果foo() 运行在非严格模式下，但在严格模式下调用它，则不影响默认绑定，this还是会绑定到全局对象。12345678funciton foo()&#123; console.log(this.a);&#125;var a = 2;(function ()&#123; "use strict"; foo(); // 2&#125;)(); 不过一般来说，最好不要在代码中混合使用strict模式和非strcit模式。 隐式绑定如果函数调用的位置有上下文对象，或者说是否被某个对象拥有或者包含，这个时候隐式绑定规则会把函数调用中的this绑定到这个上下文对象。不严谨可以说：谁调用函数，this就指向谁。123456789function foo()&#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;obj.foo(); // 2 对象属性引用链上只有上一层或者说最后一层在调用位置中起作用：123456789101112131415function foo()&#123; console.log(this.a);&#125;var obj2 = &#123; a: 42, foo: foo&#125;var obj1 = &#123; a: 2, obj2: obj2&#125;obj1.obj2.foo(); // 42 隐式丢失一个常见的this绑定问题是被隐式绑定的函数会丢失绑定对象，这个时候它会应用默认绑定，将this绑定到全局对象或者undefined上。123456789101112function foo()&#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;var bar = obj.foo; //函数别名var a = 'oops, global';bar(); // "oops, global" 虽然bar是obj.foo的一个引用，但实际上，它引用的是函数foo本身，因此这个时候bar()其实是一个不带修饰符的函数调用，故应用默认绑定。在传入回调函数时，也就是将函数作为参数传入到另一个函数中，也会发生这种情况：123456789101112131415function foo()&#123; console.log(this.a);&#125;function doFoo(fn)&#123; fn(); // 调用位置&#125;var obj = &#123; a: 2, foo: foo&#125;var a = 'oops, global';doFoo( obj.foo ); // "oops, global" 在定时器中，情况依旧：1234567891011function foo()&#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;var a = 'oops, global';setTimeOut( obj.foo, 100 ); // "oops, global" 定时器的实现类似如下代码：1234function setTimeOut(fn, delay)&#123; // 等待delay毫秒 fn(); //调用位置&#125; 隐式丢失的问题可以使用var that = this或者ES6中的箭头函数=&gt;来修复。 显式绑定如果不想在对象内部包含函数引用，而想在某个对象上强制调用函数，就可以使用call(..)和apply(..)方法：它们的第一个参数是一个对象，是给this准备的，接着在调用函数时，将这个对象绑定到this，this就指向了这个对象。第二个参数为传入的参数列表，call()和apply()略有不同：12345fn.call(thisArg, arg1, arg2, ...); // .call()接受的是若干参数的列表，用`,`号分隔fn.apply(thisArg[, arg1[, arg2[, ...]]]); // .apply()接受的是一个包含若干参数的数组，将参数“抹平”，类似于ES6中的`spread/rest`运算符`...`fn.bind(thisArg[, arg1[, arg2[, ...]]]); // .bind()与apply一致，不过它返回的是一个新函数 来看一个例子：123456789function foo()&#123; console.log(this.a);&#125;var obj = &#123; a: 2&#125;foo.call( obj ); // 2 通过foo.call(..)，在调用foo时强制把它的this绑定到了obj上。 显式绑定中的硬绑定硬绑定可以解决绑定丢失问题：12345678910111213141516function foo()&#123; console.log(this.a);&#125;var obj = &#123; a: 2&#125;var bar = function() &#123; foo.call( obj );&#125;bar(); // 2setTimeOut( bar, 100 ); // 2//硬绑定的bar不能再修改它的thisbar.call( window ); // 2 ES5提供了内置的方法 Function.prototype.bind来实现硬绑定：1234567891011function foo(something) &#123; console.log( this.a, something ); retrun this.a + something;&#125;var obj = &#123; a: 2&#125;var bar = foo.bind( obj );var b = bar(3); // 2 3console.log(b); // 5 bind(..)会返回一个硬编码的新函数，它会把你指定的参数设置为this的上下文并调用原始函数。 API调用中的“上下文”第三方库的许多函数，以及JavaScript语言和内置函数，都提供了一个可选的参数，通常被称为“上下文”，其作用和bind(..)一样，确保回调函数使用制定的this，例如forEach方法：12arr.forEach( callback( item, index, array), thisArg );// thisArg可选，当执行回调函数时用作this的值（参考对象） new绑定在Javascript中，所谓的构造函数只是一些使用new操作符时被调用的函数，并不会属于某个类，也不会实例化一个类，它们只是被new调用的普通函数而已。使用new来调用函数，或者说发生构造函数时，会自动执行一下操作： 创建（或者说构造）一个全新的对象。 这个新对象会被执行[[Prototype]]链接。 这个新对象会绑定到函数调用的this。 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 12345function foo(a)&#123; this.a = a;&#125;var bar = new foo(2);console.log( bar.a ); // 2 优先级如果某个调用位置应用了多条规则，则需要有一定的顺序来判断绑定优先级： 函数是否在new中调用？如果是的话this绑定的是创建的对象。var bar = new foo() 函数是否通过call、apply（显式绑定）或者硬绑定调用？如果是的话，this绑定的是指定的对象。var bar = foo.call(obj2) 某个函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。var bar = obj1.foo() 如果都不是的话，使用默认绑定，如果在严格模式下，就绑定到undefined，否则绑定到全局对象。 例外情况如果把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则：12345function foo()&#123; console.log(this.a);&#125;var a = 2;foo.call( null ); // 2 当使用apply(..)来展开一个数组，并当作参数传入一个函数，或者使用bind()对参数进行柯里化时，我们会传入null来实现：123456789function foo(a, b)&#123; console.log("a:" + a + ", b:" + b);&#125;// 把数组展开成参数foo.apply(null, [2, 3]); // a:2, b:3// 使用bind(..)进行柯里化var bar = foo.bind(null, 2);bar(3); // a:2, b:3 但在一些情况下，使用null来忽略this绑定可能产生一些副作用，比如某个函数确实使用了this，那么默认绑定就会把this指向全局对象，这将导致不可预计的后果（比如修改全局对象），这个时候我们可能需要一个“真正”的空对象来进行this绑定。在Javascript中创建一个空对象最简单的方法是Object.create(null)，它和{}很像，但是不会创建Object.prototype这个委托，故它比{}更空：12345678910function foo(a, b)&#123; console.log("a:" + a + ", b:" + b);&#125;var empty = Object.create(null);foo.apply(empty, [2,3]); // a:2, b:3var bar = foo.bind(empty, 2);bar(3); // a:2, b:3 箭头函数=&gt;箭头函数不使用this的四种规则，而是根据外层（函数或者全局）作用域来决定this。12345678910function foo()&#123; return (a) =&gt; &#123; console.log(this.a); &#125;&#125;var obj1 = &#123; a: 2 &#125;;var obj2 = &#123; a: 3 &#125;;var bar = foo.call(obj1);bar.call(obj2); // 2, 不是3 foo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，bar的this也会绑定到obj1，箭头函数的绑定无法被修改。 箭头函数最常用于回调函数内，例如事件处理器或者定时器：12345678function foo()&#123; setTimeOut( ()=&gt;&#123; // this在词法上继承自foo() console.log(this.a); &#125;, 100);&#125;var obj = &#123; a: 2 &#125;;foo.call(obj); // 2 如果在ES5中，则是我们常用的that：123456789function foo()&#123; var that = this; setTimeOut( ()=&gt;&#123; // this在词法上继承自foo() console.log(that.a); &#125;, 100);&#125;var obj = &#123; a: 2 &#125;;foo.call(obj); // 2 箭头函数在后面可能会单独写blog另说，到时候再深入讨论。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>随写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ES6总结之解构赋值》]]></title>
    <url>%2F2018%2F03%2F25%2F%E3%80%8AES6%E6%80%BB%E7%BB%93%E4%B9%8B%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E3%80%8B%2F</url>
    <content type="text"><![CDATA[ES6中新增了变量的解构赋值语法，在一些新的框架内，我们可能很容易就看到解构的应用，语义简洁明了，方便我们将数组或者对象属性进行结构化的赋值，以前看到这样的代码，总有点云里雾里的感觉，这两天抽了点时间，将这个小知识点做了一个总结，以后会尽量尝试使用解构语法来书写代码。 解构spread/rest运算符讲解构之前，我们先来看一个ES6中新增的运算符...，称为“spread/rest”运算符，主要根据使用的场景来区分叫法（展开/收集）。 spread展开...用到数组前面时，它会把这个变量展开为各个独立的值：1234function foo(a, b, c)&#123; console.log(a, b, c);&#125;foo(...[1,2,3]); // 1 2 3 ...[1,2,3]将数组展开，带入函数参数中。...也可以在其他上下文中展开一个值：123var a = [2, 3, 4];var b = [1, ...a, 5];console.log(b); // [1, 2, 3, 4, 5] 这里，...代替了concat(..)，如：[1].concat( a, [5] )。 rest收集...也可以把一系列值收集到一起成为一个数组：1234function foo(x, y, ...z)&#123; console.log(x, y, z);&#125;foo(1, 2, 3, 4, 5); // 1 2 [3, 4, 5] ...z就是将剩下的参数收集到一起组成一个名为z的数组，但如果没有名称参数的话，...会收集所有参数：1234function foo(...args)&#123; console.log( args );&#125;foo(1, 2, 3, 4, 5); // [1,2,3,4,5] ...args通常称为“rest参数”，是arguments数组的替代品。函数foo(..)申明中...args收集参数，console.log(..)中...args将其展开，很好的展示了运算符...对称而又相反的用法。 解构的默认值解构允许默认值，而且默认值不仅可以是简单值，还可以是任意合法的表达式，甚至可以是函数调用。12345var [a=1,b] = [undefined];console.log(a); // 1var [a=null] = [null];console.log(a); // null 默认表达式是惰性求值的，只有当参数省略或者为undefined的时候才会运行。注意，传值为null会仍会被识别为null。12345678910111213141516function bar(val)&#123; console.log('bar called'); return y + val;&#125;function foo(x = y+3, z = bar(x))&#123; console.log(x, z);&#125;var y = 5;foo(); // "bar called" 8 13foo(10); // "bar called" 10 15y = 6;foo(undefined, 10); // 9 10foo(null, 1); // null 1 另一个需要注意的地方是，函数声明中的形参首先会匹配它们自己的作用域，也就是括号内，然后才会搜索外层作用域：12345var w = 1, z = 2;function foo( x = w+1, y = x+1, z = z + 1 )&#123; console.log(x,y,z);&#125;foo(); // ReferenceError w先在括号内寻找没有，接着在外层找到1，x+1时x已初始化，故y此时为3，到z+1时，z发现自己还没有初始化，所以直接报错，永远不会试图去外层作用域寻找z。 数组的解构赋值先通过一些例子引入：1234567891011var [a, [ b, c ]] = [1, [ 2, 3 ]];console.log( a, b, c); // 1 2 3var [ , , a] = [1, 2, 3];console.log(a); // 3var [a, ...b] = [1,2,3,4,5];console.log(a, b); // 1 [2,3,4,5]var [a, b, ...c] = [1];console.log(a, b, c); // 1 undefined [] 这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值，如果解构不成功，变量的值就等于undefined。如果等号左边的模式，只匹配一部分的等号右边的数组，称之为“不完全解构”，这种情况下，解构依然可以成功。12var [a, b] = [1,2,3,4,5];console.log(a,b); // 1 2 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 对象的解构赋值对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。123456var &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"var &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 之所以{bar: bar, foo: foo}可以简写为{ bar, foo }是因为变量名与属性名一致，若不一致，则不能简写：1234567let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // "aaa"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world 另一个需要重点注意的是，{bar:bar, foo:foo}的简写省略的是前面的bar:和foo:，与对象的target: source正好相反，解构赋值的结构是source: target，后面才是要赋值的目标变量。一定要清楚简写省略的是什么，不要搞晕。 与数组一样，解构也可以用于嵌套结构的对象。12345678910let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World" 注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。1234567891011let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World"p // ["Hello", &#123;y: "World"&#125;] 下面是对象的嵌套赋值：1234567let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;); //注意用括号括起来obj // &#123;prop:123&#125;arr // [true] 注意，对于对象解构赋值来说，如果省略了var/let/const声明符，就必须把整个赋值表达式用()括起来，不然{...}部分就会被当作一个块语句，进而报错。 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。12let &#123;length : len&#125; = 'hello';len // 5 重复赋值对象解构形式允许多次列出同一个源属性：123var &#123; a: X, a: Y &#125; = &#123; a: 1 &#125;X; // 1Y; // 1 也可以解构子对象/数组属性，同时捕获子对象/类的值本身：123456789101112var &#123; a:&#123;x: X, x: Y&#125;, a&#125; = &#123; a: &#123;x: 1&#125;&#125;;X; // 1Y; // 1a; // &#123; x: 1&#125;(&#123; a: X, a: Y, a: [Z]&#125; = &#123; a: [1]&#125;);X.push(2);Y[0] = 10;X; // [10, 2]Y; // [10, 2]Z; // 1 X，Y都指向同一数组，引用复制，故为[10, 2]; 函数参数的解构赋值函数的参数也可以使用解构赋值。12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。函数参数的解构也可以使用默认值。123456789function foo(&#123; x = 10 &#125; = &#123;&#125;, &#123; y &#125; = &#123; y: 10 &#125;)&#123; console.log( x, y );&#125;foo(); // 10 10foo(undefined, undefined); // 10 10foo(&#123;&#125;, undefined); // 10 10foo(&#123;&#125;, &#123;&#125;); // 10 undefinedfoo(undefined, &#123;&#125;); // 10 undefinedfoo( &#123;x: 2&#125;, &#123;y: 3&#125;); // 2 3 undefined会触发函数参数的默认值。 用途解构赋值用途很多 交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。1234567891011121314// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来。1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据解构赋值对提取 JSON 对象中的数据，尤其有用。12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] 上面代码可以快速提取 JSON 数据的值。 函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ES6总结之Generator与Iterator下》]]></title>
    <url>%2F2018%2F03%2F17%2F%E3%80%8AES6%E6%80%BB%E7%BB%93%E4%B9%8BGenerator%E4%B8%8EIterator%E4%B8%8B%E3%80%8B%2F</url>
    <content type="text"><![CDATA[上篇博客归纳总结了一些关于Generator生成器的知识点，这些天又查阅了许多资料和书籍，包括《你不知道的JavaScript》及阮一峰老师写的《ECMAScript 6 入门》，着重理解和思考了关于Iterator迭代器的知识点，总结于此，方便以后查阅。 Iterator 迭代器迭代器（iterator）是一个结构化的模式，用于从“源”以一次一个的方式提取数据，是一种有序的、连续的、基于拉取的用于“消耗数据”的组织方式。通俗的来讲，Iterator为不同的数据结构（例如数组，字符串等）提供了一个统一的访问机制，可以对数据结构进行遍历操作（只要该数据结构部署了Iterator接口）。其作用主要有3个： 为各种数据结构，提供一个统一的、简便的访问接口； 使得数据结构的成员能够按某种次序排列； ES6 创造了一种新的遍历命令for..of循环，Iterator 接口主要供for..of消费。 接口首先要明确一点，Iterable和Iterator两个概念是不同的，Iterable是一种类型，意为“可迭代的”，Array、String、Map和Set等类型都原生实现了@@iterator方法，也就是说这些类型可以迭代，相比于Object就必须我们自己去实现迭代的方法（后面再讲）。 接口要求《你不知道的JavaScript》一书中简单介绍了一下Iterator的接口，标准是否调整我并没有查到相关资料，但是列在这里可以更清晰的理解Iterator的接口，其要求如下：12Iterator [required] next() &#123;method&#125;: 取得下一个IteratorResult 有些迭代器还扩展支持两个可选成员：123Iterator [optional] return() &#123;method&#125;: 停止迭代器并返回IteratorResult throw() &#123;method&#125;: 报错并返回IteratorResult IteratorResult接口的指定如下：123IteratorResult value() &#123;property&#125;: 当前迭代值或者最终返回值 done() &#123;property&#125;: 布尔值，指示完成状态 还有一个Iterable接口，用来表述必需能够提供生成器的对象：12Iterable @@iterator() &#123;method&#125;: 产生一个 Iterator IteratorResult接口指定了从任何迭代器操作返回的值必须是下面这种形式的对象：1&#123; value: .. , done: true/false &#125; 内置的迭代器总是返回这种形式的值，自定义迭代器可以在结果对象上增加额外的元数据（如数据的来源，获取数据的时间长度，缓存过期时长，下次请求的适当频率等…） 接口目的Iterator接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for..of循环（详见下文）。当使用for..of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。一种数据结构只要部署了Iterator接口，我们就称这种数据结构是“可遍历的”（iterable）。ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性上，只要一个数据接口有Symbol.iterator属性，就可以认为该数据接口“可遍历”，Symbol.iterator属性本身是一个函数，执行这个函数，就返回一个遍历器。属性名Symbol.iterator需要放在方括号内：123456789101112var obj = &#123; [Symbol.iterator]: function()&#123; return &#123; next() &#123; return &#123; value: 1, done: false &#125; &#125; &#125; &#125;&#125; 上面代码中，对象obj是可遍历的（iterable），因为具有Symbol.iterator属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有next方法。每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。 数据结构ES6中一些数据结构原生具备了Iterator接口，直接调用这个接口，就会返回一个遍历器对象，这些数据结构有： Array Map Set String TypedArray 函数的arguments对象 NodeList对象 例如数组的Symbol.iterator属性:1234567var arr = [1,2,3,4];var it = arr[Symbol.iterator]();it.next(); // &#123;value: 1, done: false&#125;it.next(); // &#123;value: 2, done: false&#125;it.next(); // &#123;value: 3, done: false&#125;it.next(); // &#123;value: 4, done: false&#125;it.next(); // &#123;value: undefined, done: true&#125; 变量arr是一个数组，原生就具有遍历器接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到遍历器对象。 对于原生部署Iterator接口的数据结构，不用自己写遍历器生成函数，for..of循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的Iterator接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for..of循环遍历。对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。一个对象如果要具备可被for..of循环调用的Iterator 接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。12345678910111213141516171819202122232425262728//实现一个斐波那契序列var Fib = &#123; [Symbol.iterator]() &#123; var n1 = 1, n2 = 1; return &#123; //使迭代器成为iterable [Symbol.itertor]() &#123; return this; &#125;, next() &#123; var current = n2; n2 = n1; n1 = n1 + current; return &#123; value: current, done: false &#125;; &#125;, return(v) &#123; console.log("Fibonacci sequence abandoned."); return &#123; value: v, done: true &#125;; &#125; &#125; &#125;&#125;;for( var v of Fib )&#123; console.log(v); if(v &gt; 50) break;&#125;// 1 1 2 3 5 8 13 21 34 55// Fibonacci sequence abandoned. 调用Fib[Symbol.iterator]()方法时，会返回带有 next()和 return()方法的迭代器对象。 一个需要注意的地方是类数组对象调用Symbol.iterator的情况：12345678910let iterable = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator]&#125;;for( let item of iterable )&#123; console.log(item); // 'a' 'b' 'c'&#125; 使用场合解构赋值对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。结构赋值会有专门的一篇博客来总结。1234567let set = new Set().add('a').add('b').add('c');let [x,y] = set;// x='a'; y='b'let [first, ...rest] = set;// first='a'; rest=['b','c']; 扩展预算符扩展运算符（…）也会调用默认的Iterator接口。12345678// 例一var str = 'hello';[...str] // ['h','e','l','l','o']// 例二let arr = ['b', 'c'];['a', ...arr, 'd']// ['a', 'b', 'c', 'd'] 实际上，这提供了一种简便机制，可以将任何部署了Iterator接口的数据结构，转为数组。也就是说，只要某个数据结构部署了Iterator接口，就可以对它使用扩展运算符，将其转为数组。 yield*如果yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。1234567891011121314let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; 其他场合由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。 for…of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])） Promise.all() Promise.race() 可选的return(..)和throw(..)return方法的使用场合是，如果for..of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。123456789101112131415function readLinesSync(file) &#123; return &#123; [Symbol.iterator]() &#123; return &#123; next() &#123; return &#123; done: false &#125;; &#125;, return() &#123; file.close(); return &#123; done: true &#125;; &#125; &#125;; &#125;, &#125;;&#125; 上面代码中，函数readLinesSync接受一个文件对象作为参数，返回一个遍历器对象，其中除了next方法，还部署了return方法。下面的三种情况，都会触发执行return方法。1234567891011121314151617// 情况一for (let line of readLinesSync(fileName)) &#123; console.log(line); break;&#125;// 情况二for (let line of readLinesSync(fileName)) &#123; console.log(line); continue;&#125;// 情况三for (let line of readLinesSync(fileName)) &#123; console.log(line); throw new Error();&#125; 上面代码中，情况一输出文件的第一行以后，就会执行return方法，关闭这个文件；情况二输出所有行以后，执行return方法，关闭该文件；情况三会在执行return方法关闭文件之后，再抛出错误。注意，return方法必须返回一个对象，这是Generator规格决定的。 throw(..)方法用于向迭代器报告一个异常/错误，主要是配合Generator函数使用。 迭代器循环ES6的for..of循环直接消耗一个符合规范的iterable。如果一个迭代器iterator也是一个iterable，那么它可以直接用于for..of循环，可以通过为迭代器提供一个Symbol.iterator方法简单的返回这个迭代器本身使它成为iterable:1234567var it = &#123; //使迭代器成为iterable [Symbol.iterator]() &#123; return this; &#125;, next() &#123; .. &#125;, ..&#125;it[Symbol.iterator]() === it; // true 现在可以使用for..of循环消耗这个it迭代器：123for(var v of it)&#123; console.log(v);&#125; 参照下面的例子和上面的Fib对象对比来看：12345678910111213141516171819202122232425class RangeIterator &#123; constructor(start, stop)&#123; this.value = start; this.stop = stop; &#125; [Symbol.iterator]() &#123; return this; &#125; next() &#123; var value = this.value; if(value &lt; this.stop)&#123; this.value ++; return &#123; value: value, done: false &#125;; &#125; return &#123; value: undefined, done: true &#125;; &#125;&#125;function range(start, stop)&#123; //隐藏细节 return new RangeIterator(start, stop);&#125;for( var value of range(0, 3) )&#123; console.log(value); // 0, 1, 2&#125; for..of循环一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for..of循环遍历它的成员。也就是说，for..of循环内部调用的是数据结构的Symbol.iterator方法。for..of循环可以使用的范围包括数组、Set 和Map结构、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、后文的 Generator对象，以及字符串。 数组JavaScript原有的for..in循环，只能获得对象的键名，不能直接获取键值。ES6提供for..of循环，允许遍历获得键值。123456789var arr = ['a', 'b', 'c', 'd'];for (let k in arr) &#123; console.log(k); // 0 1 2 3&#125;for (let v of arr) &#123; console.log(v); // a b c d&#125; for..of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for..in循环也不一样。12345678910let arr = [3, 5, 7];arr.foo = 'hello';for (let k in arr) &#123; console.log(k); // "0", "1", "2", "foo"&#125;for (let v of arr) &#123; console.log(v); // "3", "5", "7"&#125; 上面代码中，for..of循环不会返回数组arr的foo属性。 类似数组的对象类似数组的对象包括好几类。下面是for..of循环用于字符串、DOM NodeList对象、arguments对象的例子。123456789101112131415161718192021//字符串let str = 'hello';for (let s of str)&#123; console.log(s); // h e l l o&#125;//DOM NodeList对象let paras = document.querySelectorAll("p");for(let p of paras)&#123; p.classList.add('test');&#125;// arguments对象function printArgs() &#123; for (let x of arguments) &#123; console.log(x); &#125;&#125;printArgs('a', 'b');// 'a'// 'b' 对于字符串来说，for..of循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。12345for (let x of 'a\uD83D\uDC0A') &#123; console.log(x);&#125;// 'a'// '\uD83D\uDC0A' 并不是所有类似数组的对象都具有Iterator接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。1234567891011let arrayLike = &#123; length: 2, 0: 'a', 1: 'b' &#125;;// 报错for (let x of arrayLike) &#123; console.log(x);&#125;// 正确for (let x of Array.from(arrayLike)) &#123; console.log(x);&#125; 对象对于普通的对象，for..of结构不能直接使用，会报错，必须部署了Iterator接口后才能使用。但是，这样情况下，for..in循环依然可以用来遍历键名。1234567891011121314151617let es6 = &#123; edition: 6, committee: "TC39", standard: "ECMA-262"&#125;;for (let e in es6) &#123; console.log(e);&#125;// edition// committee// standardfor (let e of es6) &#123; console.log(e);&#125;// Uncaught TypeError: es6 is not iterable 一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。123for (var key of Object.keys(someObject)) &#123; console.log(key + ': ' + someObject[key]);&#125; 另一个方法是使用Generator函数将对象重新包装一下。123456789101112function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]]; &#125;&#125;for (let [key, value] of entries(obj)) &#123; console.log(key, '-&gt;', value);&#125;// a -&gt; 1// b -&gt; 2// c -&gt; 3 与其他遍历语法的比较以数组为例，JavaScript提供多种遍历语法。最原始的写法就是for循环:123for (var index = 0; index &lt; myArray.length; index++) &#123; console.log(myArray[index]);&#125; 这种写法比较麻烦，因此数组提供内置的forEach方法。123myArray.forEach(function (value) &#123; console.log(value);&#125;); 这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。 for..in循环可以遍历数组的键名。123for (var index in myArray) &#123; console.log(myArray[index]);&#125; for..in循环有几个缺点： 数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等； for..in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键； 某些情况下，for..in循环会以任意顺序遍历键名。 总之，for..in循环主要是为遍历对象而设计的，不适用于遍历数组。而for..of循环相比上面几种做法，有一些显著的优点: 有着同for..in一样的简洁语法，但是没有for..in那些缺点。 不同于forEach方法，它可以与break、continue和return配合使用，如上面的Fib对象 提供了遍历所有数据结构的统一操作接口。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ES6总结之Generator与Iterator上》]]></title>
    <url>%2F2018%2F03%2F11%2F%E3%80%8AES6%E6%80%BB%E7%BB%93%E4%B9%8BGenerator%E4%B8%8EIterator%E4%B8%8A%E3%80%8B%2F</url>
    <content type="text"><![CDATA[在ES6之前，JavaSript中默认来讲，一个函数一旦开始执行，就会一直运行到函数结束，期间不会有其他代码能够打断它并插入其间。虽然JavaScript是单线程运行，但是如果如果有多个函数“并行”运行，基于运行环境的复杂性及函数异步同步问题，相同的代码在多次运行中可能会出现不同的运行顺序，导致运行结果的不确定。这种函数的不确定性就是通常所说的竞态条件，两个函数相互竞争，看谁先运行。好在ES6为我们带来了Generator和Iterator,也就是所谓的生成器和迭代器（遍历器），使我们能够实现函数的启停控制，遍历数据等等新的操作。 Generator生成器总览Generator形式上就是一个普通的函数，不过有两个特征：一是function关键字与函数名之间有个*号，*的位置可以靠左也可以靠右；二是函数体内会使用yield表达式，定义不同的内部状态，函数运行到yield处会暂停，同时yield也实现了生成器内外的消息通讯功能。123456789function *foo()&#123; var y = x * (yield); return y;&#125;var it = foo(6); //构造一个迭代器it，同时传入参数6it.next(); //启动生成器var res = it.next(7); //将参数7传入*foo内的yield处，继续运行，直到下一个yield或者returnres.value; // 42 it = foo(6)并没有执行生成器*foo()，只是构造了一个迭代器，迭代器控制它的执行； 第一次调用迭代器的next()方法，启动生成器，一直运行到yield处； 再次调用next()方法，同时传入参数7至yield处，继续运行； next()的调用结果返回一个对象{value: str, done: boolean},其中的value属性保存着从*foo()返回的值（如果有的话）； 有几个需要注意的点： 消息是双向传递的，yield..作为一个表达式可以发出消息响应next(..)的调用，next(..)也可以向暂停的yield表达式发送值。 只有暂停的yield才能接收一个通过next(..)传递的值，也就是说作为启动的第一个next()还没有yield来接收它传入的值，所以浏览器会默默丢弃传递给第一个next()的任何东西，所以一定不要给迭代器的一个next()方法传入值。 多个迭代器每次构建一个迭代器，实际上就隐式的创建了生成器的一个实例，通过这个迭代器来控制的是这个生成器的实例。同一个生成器的实例可以同时运行，也可以彼此交互运行：12345678910111213141516171819function *foo()&#123; var x = yield 2; z++; var y = yield( x * z ); console.log( x, y, z);&#125;var z = 1;var it1 = foo();var it2 = foo();var val1 = it1.next().value; //启动生成器，返回的是第一个yield处的值：2var val2 = it2.next().value; //启动生成器，返回的是第一个yield处的值：2val1 = it1.next( val2 * 10 ).value; //将 val2 * 10 也就是20传入第一个yield处，将x赋值为20，z++为2，返回x*z 40val2 = it2.next( val1 * 5 ).value; //将 val1 * 5 也就是200传入第一个yield处，将x赋值为200，z++为3，返回x*z 600it1.next( val2 / 2 ); //继续运行，将val2 / 2也就是300传入第二个yield处，将y赋值为300，打印出来 20，300，3it2.next( val1 / 4 ); //继续运行，将val1 / 2也就是10传入第二个yield处，将y赋值为300，打印出来 200，10，3 yield表达式yield表达式在生成器函数中表示暂停，只有继续调用迭代器的next()方法才会遍历下一个内部状态，迭代器的next()方法运行逻辑如下： 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 如果该函数没有return语句，则返回的对象的value属性值为undefined。 yield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。 Generator函数如果不使用yield表达式，就变成了一个暂缓执行函数：12345678function *foo()&#123; console.log('执行');&#125;var it = foo();setTimeout(function()&#123; it.next();&#125;, 2000) 如果foo为普通函数，那么在为it赋值时就会执行，但是foo是一个generator函数，只有调用it的next()方法时，函数才会执行。注意：yield表达式只能用在generator函数中，用在其它地方都会报错。 Generator.prototype.throw()Generator 函数返回的迭代器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。12345678910111213141516171819var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log('内部捕获', e); &#125;&#125;;var it = g();it.next();try &#123; it.throw('a'); it.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 内部捕获 a// 外部捕获 b 上面代码中，迭代器对象it连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。it第二次抛出错误，由于 Generator函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了Generator函数体，被函数体外的catch语句捕获。throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。123456789101112var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log(e); &#125;&#125;;var it = g();it.next();it.throw(new Error('出错了！'));// Error: 出错了！(…) 注意，不要混淆迭代器对象的throw方法和全局的throw命令。上面代码的错误，是用迭代器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。123456789101112131415161718192021var g = function* () &#123; while (true) &#123; try &#123; yield; &#125; catch (e) &#123; if (e != 'a') throw e; console.log('内部捕获', e); &#125; &#125;&#125;;var it = g();it.next();try &#123; throw new Error('a'); throw new Error('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 外部捕获 [Error: a] 上面代码之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块里面剩余的语句了。 如果Generator函数内部没有部署try...catch代码块，那么throw方法抛出的错误，将被外部try...catch代码块捕获。1234567891011121314151617var g = function* () &#123; while (true) &#123; yield; console.log('内部捕获', e); &#125;&#125;;var it = g();it.next();try &#123; it.throw('a'); it.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 外部捕获 a 上面代码中，Generator函数g内部没有部署try...catch代码块，所以抛出的错误直接被外部catch代码块捕获。 如果Generator函数内部和外部，都没有部署try...catch代码块，那么程序将报错，直接中断执行。12345678910var gen = function* gen()&#123; yield console.log('hello'); yield console.log('world');&#125;var g = gen();g.next();g.throw();// hello// Uncaught undefined 上面代码中，g.throw抛出错误以后，没有任何try…catch代码块可以捕获这个错误，导致程序报错，中断执行。 throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。1234567891011121314var gen = function* gen()&#123; try &#123; yield console.log('a'); &#125; catch (e) &#123; // ... &#125; yield console.log('b'); yield console.log('c');&#125;var g = gen();g.next() // ag.throw() // bg.next() // c 上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，只要Generator 函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。 Generator.prototype.return()Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return('foo') // &#123; value: "foo", done: true &#125;g.next() // &#123; value: undefined, done: true &#125; 上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。 如果return方法调用时，不提供参数，则返回值的value属性为undefined。12345678910function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return() // &#123; value: undefined, done: true &#125; 如果Generator函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完再执行。1234567891011121314151617function* numbers () &#123; yield 1; try &#123; yield 2; yield 3; &#125; finally &#123; yield 4; yield 5; &#125; yield 6;&#125;var g = numbers();g.next() // &#123; value: 1, done: false &#125;g.next() // &#123; value: 2, done: false &#125;g.return(7) // &#123; value: 4, done: false &#125;g.next() // &#123; value: 5, done: false &#125;g.next() // &#123; value: 7, done: true &#125; 上面代码中，调用return方法后，就开始执行finally代码块，然后等到finally代码块执行完，再执行return方法。 next()、throw()、return() 的共同点next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让Generator 函数恢复执行，并且使用不同的语句替换yield表达式。 next()是将yield表达式替换成一个值：1234567891011const g = function* (x, y) &#123; let result = yield x + y; return result;&#125;;const gen = g(1, 2);gen.next(); // Object &#123;value: 3, done: false&#125;gen.next(1); // Object &#123;value: 1, done: true&#125;// 相当于将 let result = yield x + y// 替换成 let result = 1; 上面代码中，第二个next(1)方法就相当于将yield表达式替换成一个值1。如果next方法没有参数，就相当于替换成undefined。 throw()是将yield表达式替换成一个throw语句。123gen.throw(new Error('出错了')); // Uncaught Error: 出错了// 相当于将 let result = yield x + y// 替换成 let result = throw(new Error('出错了')); return()是将yield表达式替换成一个return语句。123gen.return(2); // Object &#123;value: 2, done: true&#125;// 相当于将 let result = yield x + y// 替换成 let result = return 2; 未完待续…]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宽松相等和严格相等]]></title>
    <url>%2F2018%2F03%2F03%2F%E5%AE%BD%E6%9D%BE%E7%9B%B8%E7%AD%89%E5%92%8C%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89%2F</url>
    <content type="text"><![CDATA[上次总结了一些强制类型转换的问题，今天来讲一讲与之相关的一个知识点：宽松相等和严格相等。一般说法是“==检查值是否相等，===检查值和类型是否相等”，这个说法咋一听没有问题，但是还不够严谨，正确的解释应该是：“==允许在相等比较中进行强制类型转换，而===不允许”。 概述首先有两个特例要牢记： NaN 不等于 NaN +0 等于 -0 还规定：两个对象（包括数组和函数）指向同一个值时即视为相等，不发生强制类型转化；==在比较两个不同类型的值时会发生隐式强制类型转化，会将其一或者两者都转换为相同的类型之后再进行比较。 字符串和数字之间的相等比较规定：字符串和数字比较，先将字符串转换为数字之后再进行相等比较。12345var a = 42;var b = '42';a === b; // falsea == b; // true 字符串b会先转换为数字之后再跟a进行比较。 其他类型和布尔类型之间的相等比较规定：其他类型和布尔类型比较，先将布尔类型转换为数字之后再进行比较。==最容易出错的地方就是true和false与其他类型的比较：123456var a = '42';var b = true;var c = false;a == b; // falsea == c; // false 字符串a既不是true也不是false，但字符串a确实是个真值。注意，这里的==比较并不涉及对于a的ToBoolean操作，所以字符串a是真值还是假值跟 == 本身没有关系！强烈建议：无论什么情况下都不要使用 == true 和 == false。这里面会有很多坑，一定不要手贱使用这种比较方式。 null和undefined之间的相等比较规定：在 == 中 null 和 undefined 相等（它们也跟其自身相等），除此之外其他值都不存在这种情况。12null == undefined; // trueundefined == null; // true 12345678910111213var a = null;var b;a == b; // truea == null; // trueb == null; // truea == false; // falseb == false; // false 记得上面的建议吗？a == ''; // falseb == ''; // falsea == 0; // falseb == 0; // false 平时代码判断中：1234var a == doSomething();if(a == null)&#123; //..&#125; 条件判断 a == null 只有在 doSomething 返回 null和undefined 时才成立，除此之外其他值都不成立，包括 0、false和&quot;&quot;这样的值。如果使用显式判断，就要使用严格相等 ===1234var a == doSomething();if(a === null || a === undefined)&#123; //..&#125; 对象和非对象之间的相等比较规定：字符串或数字与对象比较，先将对象进行ToPrimitive操作后再进行比较。注意，布尔类型与对象比较，根据上面定义的规则，布尔类型会转换为数字，再进行比较。12345var a = 'abc';var b = Object(a); //和 new String(a) 一样a === b; // falsea == b; // true a == b 结果为true，因为 b 通过 ToPrimitive 操作进行强制类型转换，并返回标量基本类型值 ‘abc’，与 a 相等。还有一些特例：1234567891011var a = null;var b = Object(a); // 和Object()一样a == b; // falsevar c = undefined;var d = Object(c); // 和Object()一样c == d; // falsevar e = NaN;var f = Object(e); // 和 new Number(e) 一样e == f; // false 因为没有对应的封装对象，所以null和undefined不能够被封装，Object(null)和Object()均返回一个常规对象。NaN能够被封装为数字封装对象，但拆封之后 NaN == NaN 返回false，因为NaN不自等。 一些特例及比较策略有一些比较难绕的例子，列出来希望能记住：1234567"0" == false; // truefalse == 0; // truefalse == ""; // truefalse == []; // true"" == 0; // true"" == []; // true0 == []; // true 以上有四种涉及 == false，我们说过要避免，所以不难掌握。我们总结两条比较规则，就能避开以上奇葩的情况： 如果两边的值中有 true或false，千万不要使用 ==。 如果两边的值中有 []、&quot;&quot;或0，尽量不要使用 ==，可以使用 ===。 注意：相等比较不要跟if(..){..}中条件判断式弄混，如if([]){ .. }中，[]是真值，跟false == []是不同的概念，不要弄晕！ 抽象关系比较这里简单介绍一下 a &lt; b这种大小比较。规则： 比较双方先调用ToPrimitive，如果出现非字符串，就根据 ToNumber 规则将双方强制类型转换为数字进行比较。 1234var a = [ 42 ];var b = [ "43" ];a &lt; b; // trueb &lt; a; // false 如果比较双方都是字符串，则按字母顺序来进行比较。 123var a = [ "42" ];var b = [ "043" ];a &lt; b; // false a和b并没有转换成数字，这里ToPrimitive返回的是字符串，进行了字符串的比较，’0’小于’4’。 123var a = [4,2];var b = [0,4,3];a &lt; b; // false 这里a转换为”4,2”，b转换为”0,4,3”，字符串比较。 123var a = &#123; b: 42 &#125;;var b = &#123; b: 43 &#125;;a &lt; b; // false 这里 a和b都转换成了 [Object Object]，故a&lt;b不成立，这里要注意，看下面的例子：12345678var a = &#123; b: 42 &#125;;var b = &#123; b: 43 &#125;;a &lt; b; // falsea == b; // false 相等操作的话要看上面！a &gt; b; // falsea &lt;= b; // truea &gt;= b; // true 注意最后两条，根据规定：a &lt;= b会被处理为 b &lt; a 然后将结果反转。因为 b &lt; a 的结果是 false，所以 a &lt;= b 的结果是 true。JavaScript中 &lt;= 是不大于的意思，即 !(a &gt; b)，处理为 !(b &lt; a)。同理，a &gt;= b处理为 b &lt;= a。相等比较有严格相等，但关系比较却没有“严格关系比较”，也就是说要避免 a &lt; b 中发生隐式强制类型转换，为了保证安全，应该对关系比较中的值进行显式强制类型转换：1234var a = [ 42 ];var b = "043";a &lt; b; // false 字符串的比较Number(a) &lt; Number(b); // true 数字比较]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>知识积累</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强制类型转换]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[今天来谈谈JavaScript中的强化类型转换。将值从一种类型转换为另一种类型通常称为类型转换，这是显式情况，隐式的情况称为强制类型转换。这里再将强制类型转换区分为显式强制类型转换和隐式强制类型转换。当然这个区分是相对而言的。 抽象值操作ToStringToString负责处理非字符串到字符串的强制类型转换。转换规则：null转换为&quot;null&quot;、undefined转换为&quot;undefined&quot;、true转换为&quot;true&quot;、数字的转换遵守通用规则，极大和极小值使用指数形式：12var a = 2.34 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;a.toString(); // "2.34e21" 对普通对象来说，如果有自己的toString()方法，字符串化时会调用该方法并使用其返回值，否则Object.prototype.toString()返回内部属性[[Class]]的值，如&quot;[Object Object]&quot;。对数组来说，数组的默认toString()方法经过的重新定义，将所有的单元字符串化后再用,连接起来：12var a = [1,2,3];a.toString(); // "1,2,3" ToNumberToNumber负责将数字值当作数字使用。转换规则：true转换为1、false转换为0、undefined转换为NaN、null转换为0。ToNumber对字符串的处理基本遵守数字常量的规则，处理失败时返回NaN，不同之处是ToNumber对以0开头的十六进制数并不按十六进制处理，而是按十进制。 对象（包括数组）会首先转换成相应的基本类型值，如果返回的是非数字类型的基本类型值，则再遵循以上规则将其强制转换为数字。这里依赖于ToPrimitive操作，先检查该值是否有valueOf()方法，如果有则返回基本类型值，再使用该值进行强制类型转换；如果没有就使用toString()的返回值来进行强制类型转换。如果valueOf()和toString()均不返回基本类型，会产生TypeError错误。注：使用Object.create(null)创建的对象[[Prototype]]属性为null，并且没有valueOf()和toString()方法，因此无法进行强制类型转换。123456789101112131415161718192021var a = &#123; valueOf: function()&#123; return "42"; &#125;&#125;;var b = &#123; toString: function()&#123; return "42"; &#125;&#125;var c = [4,2];c.toString = function()&#123; return this.join("");&#125;Number(a); // 42Number(b); // 42Number(c); // 42Number(""); // 0Number([]); // 0Number([1,2,3]); // NaN ToBoolean首先明确数字1和0跟布尔值true和false并不是一回事。JavaScript规定了一些可以被强制类型转换为false的值： undefined null false +0、-0和NaN “”以上称为假值。假值的布尔强制转换类型为false。所有的对象都是真值，逻辑上讲假值列表以外的值都是真值。1234567891011121314var a = new Boolean(false);var b = new Number(0);var c = new String("");Boolean(a); // trueBoolean(b; // trueBoolean(c); // truevar d = [];var e = &#123;&#125;;var f = function()&#123;&#125;;Boolean(d); // trueBoolean(e); // trueBoolean(f); // true// []、&#123;&#125;、function()&#123;&#125;都不在假值列表中，所以他们都是真值 以上介绍了将值转换为string、number和boolean的规则，接下来详细说明一下强制类型转换。 显式强制类型转换字符串与数字之间的显式转换字符串和数字之间是通过String()和Number()这两个内建函数来是实现的，他们前面没有new关键字，并不创建对象。1234567var a = 42;var b = String(a);var c = '3.14';var d = Number(c);b; // '42'd; // 3.14 除了String()和Number()以外，还有其他方法可以实现转换：12345678var a = 42;var b = a.toString();var c = 3.14;var d = +c;b; // '42';d; // 3.14 a.toString()是显式的，不过其中涉及隐式转换，因为toString()对42这样的基本类型不适用，所以js会自动为42创建一个封装对象，然后对该对象调用toString();+运算符显式的将c转换为数字，一元运算+被普遍认为是显式强制类型转换。+运算符的另外一个用途是将日期对象强制转换为数字，返回时间戳：1234var d = new Date("Tues, 27 Feb 2018 15:30:45 CDT");+d; // 1519763445000var timestamp = +new Date(); //常用来获取当前的时间戳 最好使用ES5中新加入的静态方法Date.now():1var timestamp = Date.now(); 注：应该使用Date.now()来获取当前的时间戳，用new Date(...).getTime()来获取指定时间的时间戳。 显式解析数字字符串解析字符串中的数字和将字符串强制类型转换为数字返回的都是数字，但解析和转换之间还是有明显的区别：1234567var a = "42";var b = "42px";Number(a); // 42parseInt(a); // 42Number(b); // NaNparseInt(b); // 42 解析允许字符串中含有非数字字符，解析按从左到右的顺序，遇到非数字字符就停止；而转换不允许出现非数字字符，否则会失败返回NaN。注：解析字符串中的浮点数可以使用parseFloat()函数。parseInt()和parseFloat()都是针对字符串值，应避免向其传递非字符串值。 显式转换为布尔值与String(..)和Number(..)一样，Boolean(..)是显式的ToBoolean强制类型转换：123456789101112131415161718var a = '0';var b = [];var c = &#123;&#125;;var d = '';var e = 0;var f = null;var g;Boolean(a); // trueBoolean(b); // trueBoolean(c); // trueBoolean(d); // falseBoolean(e); // falseBoolean(f); // falseBoolean(g); // false//参考上面的假值表 虽然Boolean(..)是显式的，但不常用。与+类型，一元运算符!显式的将值强制类型转换为布尔值，但它同时还将真值转换为假值，所以显式强制类型转换为布尔值的最常用方法是!!，第二个!将结果反转：1234567891011121314151617var a = '0';var b = [];var c = &#123;&#125;;var d = '';var e = 0;var f = null;var g;!!a; // true!!b; // true!!c; // true!!d; // false!!e; // false!!f; // false!!g; // false 建议使用Boolean(a)和!!a来进行显式强制类型转换。 隐式强制类型转换隐式强制类型转换的作用是减少冗余，让代码简洁。 字符串和数字之间的隐式强制类型转换+ 运算符既能用于数字加法，也能用于字符串拼接，如果某个操作数是字符串或者能够通过以下步骤转为字符串，+ 将进行拼接操作。即如果某个操作数是对象（包括数组），则对其调用ToPrimitive抽象操作，得到字符串，进行拼接操作。1234var a = [1,2];var b = [3,4];a + b; // '1,23,4' 数组的valueOf()操作无法得到简单的基本类型，于是接着调用toString()操作，使用,连接各元素，返回字符串。总结： 如果+ 的其中一个操作数是字符串（或者通过以上步骤能转为字符串），则执行字符串拼接操作，否则执行数字加法。我们可以将数字和空字符串””相+ 来将其转换为字符串：123var a = 42;var b = a + '';b; // "42" a + &#39;&#39; 会对a调用valueOf()方法，然后通过ToString抽象操作将返回值转换为字符串，而String(a)则是直接调用ToString()。它们最后都返回字符串，但a如果是对象的话结果可能不一样：1234567var a = &#123; valueOf: function() &#123; return 42; &#125; toString: function() &#123; return 4; &#125;&#125;a + ""; // "42"String(a); // "4" 一般不会遇到上面的情况，但是在定制valueOf()和ToString()的时候要特别小心。 - 、*、 / 运算符都只适用于数字，a-0 会将a 强制转换为数字。1234var a = [3];var b = [1];a - b; // 2 为了执行减法运算，a和b都需要转换为数字，首先被转换为字符串（通过toString()），然后再转为数字。b = String(a) （显式）和 b = a + “” （隐式）各有优点，b = a + “” 更常见一些。 隐式强制类型转换为布尔值下面的情况会发生布尔值隐式强制类型转换： if(..)语句中的条件判断表达式。 for(..; ..; ..;)语句中的条件判断表达式（第二个）。 while(..)和 do..while(..)循环中的条件判断表达式。 ? : 三元运算中的条件判断表达式。 逻辑运算符 || 和 &amp;&amp; 左边的操作数（作为条件判断表达式）。123456789101112131415161718var a = '42';var b = 'abc';var c;var d = null;if(a)&#123; console.log('yep'); // yep&#125;while(c)&#123; console.log('nope, never runs');&#125;c = d ? a : b;c; // 'abc'if((a &amp;&amp; b) || c)&#123; console.log('yep'); // yep&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>知识积累</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TypeScript学习笔记-泛型》]]></title>
    <url>%2F2018%2F01%2F15%2F%E3%80%8ATypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B3%9B%E5%9E%8B%E3%80%8B%2F</url>
    <content type="text"><![CDATA[今天来说一下TypeScript中的泛型和声明合并。 泛型泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 简单的例子首先，我们来实现一个函数createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：12345678function createArray(length: number, value: any): Array&lt;any&gt; &#123; let result = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); //['x', 'x', 'x'] 上例不会报错，但一个缺陷就是：它并没有准确的定义返回值的类型：Array&lt;any&gt;允许数组的每一项都是任意类型，但我们的预期是，数组中的每一项都应该是输入的value的类型。这时候，泛型就派上用场了。12345678function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray&lt;string&gt;(3, 'x'); //['x', 'x', 'x'] 上例中，我们在函数名后添加了&lt;T&gt;，其中T用来指代任意输入的类型，在后面的输入value: T和输出Array&lt;T&gt;中即可使用了。接着在调用的时候，可以指定它具体的类型为 string。当然，也可以不手动指定，而让类型推论自动推算出来：123456789function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); // ['x', 'x', 'x'] 多个类型参数定义泛型的时候，可以一次定义多个类型参数：1234function swap&lt;T, U&gt;(tuple: [T, U]): [U, T]&#123; return [tuple[1], tuple[0]];&#125;swap([7, 'seven']); //['seven', 7] 约束泛型在函数内部使用泛型变量时，由于事先不知道它是什么类型，所以不能随意操作它的属性或方法：12345function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125;// index.ts(2,19): error TS2339: Property 'length' does not exist on type 'T'. 上例中，泛型 T 不一定包含属性length，所以编译的时候报错了。这时，我们可以对泛型进行约束，只允许这个函数传入那些包含length属性的变量。这就是泛型约束：1234567interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125; 上例中，我们使用了extends约束了泛型T必须符合接口Lengthwise的形状，也就是必须包含length属性。此时如果调用loggingIdentity的时候，传入的arg不包含length，那么在编译阶段就会报错了：123456789101112interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125;loggingIdentity(7);// index.ts(10,17): error TS2345: Argument of type '7' is not assignable to parameter of type 'Lengthwise'. 泛型接口之前说过，可以使用接口的方式来定义一个函数需要符合的形状：12345678interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; return source.search(subString) !== -1;&#125; 当然也可以使用含有泛型的接口来定义函数的形状：123456789101112interface CreateArrayFunc &#123; &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); // ['x', 'x', 'x'] 进一步，我们可以把泛型参数提前到接口名上：1234567891011121314interface CreateArrayFunc&lt;T&gt; &#123; (length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc&lt;any&gt;;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); // ['x', 'x', 'x'] 注意，此时在使用泛型接口的时候，需要定义泛型的类型。 泛型类与泛型接口类似，泛型也可以用于类的类型定义中：1234567class GenericNumber&lt;T &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;; 泛型参数的默认类型在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。1234567function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125; 声明合并如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型： 函数的合并之前学习过，我们可以使用重载定义多个函数类型：123456789function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string &#123; if (typeof x === 'number') &#123; return Number(x.toString().split('').reverse().join('')); &#125; else if (typeof x === 'string') &#123; return x.split('').reverse().join(''); &#125;&#125; 接口的合并123456interface Alarm &#123; price: number;&#125;interface Alarm &#123; weight: number;&#125; 相当于：1234interface Alarm &#123; price: number; weight: number;&#125; 注意，合并的属性的类型必须是唯一的：1234567interface Alarm &#123; price: number;&#125;interface Alarm &#123; price: number; // 虽然重复了，但是类型都是 `number`，所以不会报错 weight: number;&#125; 123456789interface Alarm &#123; price: number;&#125;interface Alarm &#123; price: string; // 类型不一致，会报错 weight: number;&#125;// index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type. Variable 'price' must be of type 'number', but here has type 'string'. 接口中方法的合并，与函数的合并一样：12345678interface Alarm &#123; price: number; alert(s: string): string;&#125;interface Alarm &#123; weight: number; alert(s: string, n: number): string;&#125; 相当于：123456interface Alarm &#123; price: number; weight: number; alert(s: string): string; alert(s: string, n: number): string;&#125; 类的合并类的合并与接口的合并规则一致。]]></content>
      <tags>
        <tag>知识积累</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TypeScript学习笔记-枚举》]]></title>
    <url>%2F2018%2F01%2F10%2F%E3%80%8ATypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9E%9A%E4%B8%BE%E3%80%8B%2F</url>
    <content type="text"><![CDATA[今天来说一说一个比较难理解知识点，枚举（Enum）枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。 例子枚举使用enum关键字来定义：1enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125; 枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：1234567891011enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days["Sun"] === 0); // trueconsole.log(Days["Mon"] === 1); // trueconsole.log(Days["Tue"] === 2); // trueconsole.log(Days["Sat"] === 6); // trueconsole.log(Days[0] === "Sun"); // trueconsole.log(Days[1] === "Mon"); // trueconsole.log(Days[2] === "Tue"); // trueconsole.log(Days[6] === "Sat"); // true 以上例子会被编译为：12345678910var Days;(function (Days) &#123; Days[Days["Sun"] = 0] = "Sun"; Days[Days["Mon"] = 1] = "Mon"; Days[Days["Tue"] = 2] = "Tue"; Days[Days["Wed"] = 3] = "Wed"; Days[Days["Thu"] = 4] = "Thu"; Days[Days["Fri"] = 5] = "Fri"; Days[Days["Sat"] = 6] = "Sat";&#125;)(Days || (Days = &#123;&#125;)); 手动赋值我们也可以给枚举项手动赋值：12345enum Days &#123;Sun = 7, Mon = 1, Tue, Mon, Thu, Fri, Sat&#125;console.log(Days["Sun"] === 7); // trueconsole.log(Days["Mon"] === 1); // trueconsole.log(Days["Tue"] === 2); // trueconsole.log(Days["Sat"] === 6); // true 上面的例子中，未手动赋值的枚举项会接着上一个枚举项递增。如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的：123456enum Days &#123;Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days["Sun"] === 3); // trueconsole.log(Days["Wed"] === 3); // trueconsole.log(Days[3] === "Sun"); // falseconsole.log(Days[3] === "Wed"); // true 上面的例子中，递增到 3 的时候与前面的 Sun 的取值重复了，但是 TypeScript 并没有报错，导致 Days[3] 的值先是 “Sun”，而后又被 “Web” 覆盖了。手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 1：123456enum Days &#123;Sun = 7, Mon = 1.5, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days["Sun"] === 7); // trueconsole.log(Days["Mon"] === 1.5); // trueconsole.log(Days["Tue"] === 2.5); // trueconsole.log(Days["Sat"] === 6.5); // true 常数项和计算所得项枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。前面我们所举的例子都是常数项，一个典型的计算所得项的例子：1enum Color &#123;Red, Green, Blue = "blue".length&#125;; 上面的例子中，”blue”.length 就是一个计算所得项，上面的例子不会报错，但是如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错：1234enum Color &#123;Red = "red".length, Green, Blue&#125;;// index.ts(1,33): error TS1061: Enum member must have initializer.// index.ts(1,40): error TS1061: Enum member must have initializer. 下面是常数项和计算所得项的完整定义，部分引用自中文手册 - 枚举：当满足以下条件时，枚举成员被当作是常数：1、不具有初始化函数并且之前的枚举成员是常数。在这种情况下，当前枚举成员的值为上一个枚举成员的值加 1。但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 0。2、枚举成员使用常数枚举表达式初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常数枚举表达式： 数字字面量 引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的）如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用 带括号的常数枚举表达式 +, -, ~ 一元运算符应用于常数枚举表达式 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^ 二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为NaN或Infinity，则会在编译阶段报错所有其它情况的枚举成员被当作是需要计算得出的值。 常数枚举常数枚举是使用 const enum 定义的枚举类型：12345678const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。编译结果：1var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 假如包含了计算成员，则会在编译阶段报错：123const enum Color &#123;Red, Green, Blue = "blue".length&#125;;// index.ts(1,38): error TS2474: In 'const' enum declarations member initializer must be constant expression. 外部枚举外部枚举（Ambient Enums）是使用 declare enum 定义的枚举类型：12345678declare enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 之前提到过，declare 定义的类型只会用于编译时的检查，编译结果中会被删除。编译结果：1var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 外部枚举与声明语句一样，常出现在声明文件中。同时使用 declare 和 const 也是可以的：12345678declare const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 编译结果：1var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 网上查了一些资料，枚举这个概念还是云里雾里的，官方文档给出的解释更是寥寥草草，无甚解释，只能在以后遇到实际的例子时多多留意其用法，再回过头来看文档了。]]></content>
      <tags>
        <tag>知识积累</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TypeScript学习笔记-类与接口》]]></title>
    <url>%2F2018%2F01%2F09%2F%E3%80%8ATypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E3%80%8B%2F</url>
    <content type="text"><![CDATA[今天的进阶篇主要来说一下类与接口。 概述传统方法中，JavaScript通过构造函数实现类的概念，通过原型链实现继承。而在ES6中有了class。TypeScript除了实现了所有ES6中的类的功能外，还添加了一些新的用法。 类的概念先说下几个重要的概念： 类(class): 定义了一件事件的抽象特点，包含它的属性和方法 对象(Object): 类的实例，通过new生成 面向对象(OPP)的三大特点: 封装、继承、多态 封装(Encapsulation): 将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据。 继承(Inheritance): 子类继承父类，子类除了有父类的所有特性外，还有一些更具体的特性 多态(Polymorphism): 由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如Cat和Dog都是继承自Animal,但是分别实现了自己的eat方法。此时针对某一个实例，我们无需了解它是Cat还是Dog，就可以直接调用eat方法，程序会自动判断出来应该如何执行eat 存取器(getter &amp; setter): 用以改变属性的读取和赋值行为 修饰符(Modifiers): 修饰符是一些关键字，用于限定成员或类型的性质。比如public表示公有属性或方法 抽象类(Abstract Class): 抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中实现 接口(Interfaces): 不同类之间公有的属性或者方法，可以抽象成一个接口。接口可以被实现(implements)。一个类只能继承自另一个类，但是可以实现多个接口 ES6中类的用法先简单介绍一下ES6中类的用法，具体可参照阮一峰老师的ECMAScript 6 入门 - Class 属性和方法使用class定义类，使用constructor定义构造函数。通过new生成新实例的时候，会自动调用构造函数。 1234567891011class Animal &#123; constructor(name)&#123; this.name = name; &#125; sayHi() &#123; return `My name is $&#123;this.name&#125;`; &#125;&#125;let a = new Animal('Jack');console.log(a.sayHi()); //My name is Jack 类的继承使用extends关键字实现继承，子类中使用super关键字来调用父类的构造函数和方法。1234567891011class cat extends Animal &#123; constructor(name)&#123; super(name); console.log(this.name); &#125; sayHi() &#123; retrun 'Meow,' + super.sayHi(); &#125;&#125;let c = new Cat('Tom'); // Tomconsole.log(c.sayHi()); // Meow, My name is Tom 存取器使用getter和setter可以改变属性的赋值和读取行为:1234567891011121314class Animal &#123; constructor(name)&#123; this.name = name; &#125; get name()&#123; return 'Jack'; &#125; set name()&#123; console.log('setter:' + value); &#125;&#125;let a = new Animal('kitty'); //setter: kittya.name = 'Tom'; //setter: Tomconsole.log(a.name); //Jack 静态方法使用static修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用：123456789class Animal &#123; static isAnimal(a) &#123; return a instanceof Animal; &#125;&#125;let a = new Animal('Jack');Animal.isAnimal(a); // truea.isAnimal(a); // TypeError: a.isAnimal is not a function ES7中类的用法ES7 中有一些关于类的提案，TypeScript 也实现了它们，这里做一个简单的介绍。 实例属性ES6 中实例的属性只能通过构造函数中的 this.xxx 来定义，ES7 提案中可以直接在类里面定义：123456789class Animal &#123; name = 'Jack'; constructor()&#123; //... &#125;&#125;let a = new Animal();console.log(a.name); // Jack 静态属性ES7 提案中，可以使用 static 定义一个静态属性：12345678class Animal &#123; static num = 42; constructor () &#123; //... &#125;&#125;console.log(Animal.name); // 42 TypeScript中类的用法public private 和 protectedTypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。 public修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是public的 private修饰的属性或方法私有的，不能在声明它的类的外部访问 protected修饰的属性或方法是受保护的，它和private类似，区别是它在子类中也是允许访问的 1234567891011class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125;&#125;let a = new Animal('Jack');console.log(a.name); // Jacka.name = 'Tom';console.log(a.name); // Tom 上面的例子中，name被设置为了public，所以直接访问实例的name属性是允许的。很多时候，我们希望有的属性是无法直接存取的，这时候就可以用private了： 12345678910111213class Animal &#123; private name; public constructor(name) &#123; this.name = name; &#125;&#125;let a = new Animal('Jack');console.log(a.name); // Jacka.name = 'Tom';// index.ts(9,13): error TS2341: Property 'name' is private and only accessible within class 'Animal'.// index.ts(10,1): error TS2341: Property 'name' is private and only accessible within class 'Animal'. 需要注意的是，TypeScript 编译之后的代码中，并没有限制private属性在外部的可访问性。上面的例子编译后的代码是：123456789var Animal = (function () &#123; function Animal(name) &#123; this.name = name; &#125; return Animal;&#125;());var a = new Animal('Jack');console.log(a.name);a.name = 'Tom'; 使用private修饰的属性或方法，在子类中也是不允许访问的： 123456789101112131415class Animal &#123; private name; public constructor(name) &#123; this.name = name; &#125;&#125;class Cat extends Animal &#123; constructor(name) &#123; super(name); console.log(this.name); &#125;&#125;// index.ts(11,17): error TS2341: Property 'name' is private and only accessible within class 'Animal'. 而如果是用protected修饰，则允许在子类中访问：12345678910111213class Animal &#123; protected name; public constructor(name) &#123; this.name = name; &#125;&#125;class Cat extends Animal &#123; constructor(name) &#123; super(name); console.log(this.name); &#125;&#125; 抽象类abstract用于定义抽象类和其中的抽象方法。首先，抽象类不允许被实例化： 1234567891011abstract class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125; public abstract sayHi();&#125;let a = new Animal('Jack');// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class 'Animal'. 上面的例子中，我们定义了一个抽象类Animal，并且定义了一个抽象方法sayHi。在实例化抽象类的时候报错了。其次，抽象类中的抽象方法必须被子类实现：1234567891011121314151617abstract class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125; public abstract sayHi();&#125;class Cat extends Animal &#123; public eat() &#123; console.log(`$&#123;this.name&#125; is eating.`); &#125;&#125;let cat = new Cat('Tom');// index.ts(9,7): error TS2515: Non-abstract class 'Cat' does not implement inherited abstract member 'sayHi' from class 'Animal'. 上面的例子中，我们定义了一个类 Cat 继承了抽象类 Animal，但是没有实现抽象方法 sayHi，所以编译报错了。下面是一个正确使用抽象类的例子：123456789101112131415abstract class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125; public abstract sayHi();&#125;class Cat extends Animal &#123; public sayHi() &#123; console.log(`Meow, My name is $&#123;this.name&#125;`); &#125;&#125;let cat = new Cat('Tom'); 上面的例子中，我们实现了抽象方法 sayHi，编译通过了。需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类。 类的类型给类加上 TypeScript 的类型很简单，与接口类似：123456789101112class Animal &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; sayHi(): string &#123; return `My name is $&#123;this.name&#125;`; &#125;&#125;let a: Animal = new Animal('Jack');console.log(a.sayHi()); // My name is Jack 类与接口类实现接口实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用implements关键字来实现。这个特性大大提高了面向对象的灵活性。举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：1234567891011121314151617interface Alarm &#123; alert();&#125;class Door &#123;&#125;class SecurityDoor extends Door implements Alarm &#123; alert()&#123; console.log('SecurityDoor alert'); &#125;&#125;class Car implements Alarm &#123; alert() &#123; console.log('Car alert'); &#125;&#125; 一个类可以实现多个接口：12345678910111213141516171819interface Alarm &#123; alert();&#125;interface Light &#123; lightOn(); ligntOff();&#125;class Car implements Alarm, Light &#123; alert() &#123; console.log('Car alert'); &#125; lightOn() &#123; console.log('Car light on'); &#125; lightOff() &#123; console.log('Car light off'); &#125;&#125; 上例中，Car实现了Alarm和Light接口，既能报警，也能开关车灯。 接口继承接口接口与接口之间可以是继承的关系：1234567interface Alarm &#123; alert();&#125;interface LightableAlarm extends Alarm &#123; lightOn(); lightOff();&#125; 上例中，我们使用extends使LightableAlarm继承Alarm。 接口继承类接口也可以继承类：12345678910class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z:number;&#125;let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125; 混合类型可以使用接口的方式来定义一个函数需要符合的形状：12345678interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; return source.search(subString) !== -1;&#125; 有时候，一个函数还可以有自己的属性和方法：1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function (start: number) &#123; &#125;; counter.interval = 123; counter.reset = function () &#123; &#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0;]]></content>
      <tags>
        <tag>知识积累</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TypeScript学习笔记-进阶一》]]></title>
    <url>%2F2018%2F01%2F07%2F%E3%80%8ATypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%9B%E9%98%B6%E4%B8%80%E3%80%8B%2F</url>
    <content type="text"><![CDATA[今天进入进阶篇的学习和总结，先来说一下类型别名、字符串字面量类型和元祖。 类型别名类型别名用来给一个类型起个新名字 12345678910type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResoler): Name &#123; if(typeof n === 'string')&#123; return n; &#125; else &#123; return n(); &#125;&#125; 我们使用 type 创建类型别名，常用于联合类型。 字符串字面量类型字符串字面量类型用来约束取值只能是某几个字符串中的一个。123456type EventNames = 'click' | 'scroll' | 'mouseover';function handleEvent(ele: Element, event: EventNames)&#123; //do something;&#125;handleEvent(document.getElementById('hello'), 'scroll'); //编译成功handleEvent(document.getElementById('world'), 'dbclick'); //编译错误 上面我们使用type定义了一个字符串字面量类型EventNames，它只能取三种字符串中的一种。注意：类型别名和字符串子面量类型都是使用type进行定义。 元组(Tuple)数组合并了相同类型的对象，而元组合并了不同类型的对象。元组起源于函数编程语言（如 F#）,在这些语言中频繁使用元组。 简单的例子定义一对值分别为string和number的元祖：1let tom:[string, number] = ['tom', 20]; 当赋值或访问一个已知索引的元素时，会得到正确的类型：123456let tom:[string, number];tom[0] = 'tom';tom[1] = 20;tom[0].slice(1);tom[1].toFixed(2); 也可以只赋值其中一项：12let tom: [string, number];tom[0] = 'tom'; 但当直接对元祖类型的变量进行初始化或者赋值的时候，需要提供所有元祖类型中指定的项。1234567891011let tom: [string, number];tom = ['tom', 20];//编译成功let tom: [string, number] = ['tom'];//编译错误let tom: [string, number];tom = ['tom'];tom[1] = 20;//编译错误 越界的元素当赋值给越界的元素时，它的类型会被限制为元祖中每个类型的联合类型：12let tom: [string, number];tom = ['tom', 20, 'male']; 上面的例子中，数组的第三项满足联合类型 string | number。123456let tom: [string, number];tom = ['tom', 20];tom.push('male');tom.push(true);// index.ts(4,14): error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'string | number'.// Type 'boolean' is not assignable to type 'number'. 当访问一个越界的元素，也会识别为元组中每个类型的联合类型：12345let tom: [string, number];tom = ['tom', 20, 'male'];console.log(tom[2].slice(1));// index.ts(4,24): error TS2339: Property 'slice' does not exist on type 'string | number'. 之前提到过，如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的属性或方法。]]></content>
      <tags>
        <tag>知识积累</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TypeScript学习笔记-基础三》]]></title>
    <url>%2F2018%2F01%2F06%2F%E3%80%8ATypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E4%B8%89%E3%80%8B%2F</url>
    <content type="text"><![CDATA[今天来说一下基础篇剩下的一些内容：类型断言、声明文件和内置对象 类型断言类型断言（Type Assertion）可以用来手动指定一个值的类型。语法：&lt;类型&gt;值或者值 as 类型 将一个联合类型的变量指定为一个更加具体的类型之前说，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：1234function getLenth(something: string | number): number&#123; return something.length;&#125;//编译错误 而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如： 12345678function getLength(something: string | number): number &#123; if (something.length) &#123; return something.length; &#125; else &#123; return something.toString().length; &#125;&#125;//编译错误 此时，可以使用类型断言，将something断言成string:1234567function getLength(something: string | number): number &#123; if((&lt;string&gt;something).length)&#123; return (&lt;string&gt;something).length; &#125; else &#123; return something.toString().length; &#125;&#125; 类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的：1234function toBoolean(something: string | number): boolean &#123; return &lt;boolean&gt;something;&#125;//编译错误，Type 'string | number' cannot be converted to type 'boolean'. 声明文件当使用第三方库时，我们需要引入它的声明文件。 声明语句假如我们想使用第三方库，比如jQuery，我们通常这样获取一个id是foo的元素：123$('#foo');//orjQuery('#foo'); 但TS并不知道$或者jQuery是什么东西，这时候我们就需要使用declare关键字来定义它的类型，帮助TypeScript判断我们的传入的参数类型对不对：12declare var jQuery:(string) =&gt; any;jQuery('#foo'); declare定义的类型只会用于编译时的检查，编译结果中会被删除。上面编译结果为： 1jQuery('#foo'); 声明文件通常我们会把类型声明放到一个单独的文件中，这就是声明文件：12// jQuery.d.tsdeclare var jQuery: (string) =&gt; any; 我们约定声明文件以.d.ts为后缀。然后在使用到的文件开头，用三斜线指令表示引用了声明文件： 12/// &lt;reference path="./jQuery.d.ts" /&gt;jQuery('#foo'); 第三方声明文件当然，jQuery 的声明文件不需要我们定义了，已经有人帮我们定义好了：jQuery in DefinitelyTyped。我们可以直接下载下来使用，但是更推荐的是使用工具统一管理第三方库的声明文件。社区已经有多种方式引入声明文件，不过 TypeScript 2.0 推荐使用 @types 来管理。@types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：1npm install @types/jquery --save-dev 可以在这个页面搜索你需要的声明文件。 内置对象JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。 ECMAScript 的内置对象ECMAScript 标准提供的内置对象有：Boolean、Error、Date、RegExp 等。我们可以在 TypeScript 中将变量定义为这些类型：1234let b: Boolean = new Boolean(1);let e: Error = new Error('Error occurred');let d: Date = new Date();let r: RegExp = /[a-z]/; 更多的内置对象，可以查看MDN的文档。而他们的定义文件，则在TypeScript核心库的定义文件中。 DOM 和 BOM 的内置对象DOM 和 BOM 提供的内置对象有：Document、HTMLElement、Event、NodeList 等。TypeScript 中会经常用到这些类型：12345let body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll('div');document.addEventListener('click', function(e: MouseEvent) &#123; // Do something&#125;); TypeScript 核心库的定义文件TypeScript 核心库的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。当你在使用一些常用的方法的时候，TypeScript实际上已经帮你做了很多类型判断的工作了，比如：12Math.pow(10, '2');// index.ts(1,14): error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'. 上面的例子中，Math.pow 必须接受两个 number 类型的参数。事实上 Math.pow 的类型定义如下：12345678interface Math &#123; /** * Returns the value of a base expression taken to a specified power. * @param x The base value of the expression. * @param y The exponent value of the expression. */ pow(x: number, y: number): number;&#125; 用 TypeScript 写 Node.jsNode.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：1npm install @types/node --save-dev]]></content>
      <tags>
        <tag>知识积累</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TypeScript学习笔记-基础二》]]></title>
    <url>%2F2018%2F01%2F04%2F%E3%80%8ATypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E4%BA%8C%E3%80%8B%2F</url>
    <content type="text"><![CDATA[今天主要来说一下TS中对象、数组和函数的类型。 对象的类型-接口在TS中，使用接口（Interface）来定义对象的类型。 什么是接口接口是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。TS中接口除了可用于对类的一部分行为进行抽象以外，也常用于对对象的形状进行描述。 例子12345678interface Person &#123; name: string; age: number;&#125;let tom: Person = &#123; name: 'tom', age: 25&#125;; 先定义一个接口Person，接着定义一个变量tom，他的类型是Person。这样，我们就约束了tom的形状必须和接口Person一致。接口一般首字母大写。注意：赋值的时候，变量的形状必须跟接口形状一致，属性不能多也不能少。12345678910111213141516171819interface Person &#123; name: string; age: number;&#125;let tom: Person = &#123; name: 'tom', age: 25, gender: 'male'&#125;;//编译错误interface Person &#123; name: string; age: number;&#125;let tom: Person = &#123; name: 'tom'&#125;;//编译错误 可选?属性可选属性表示该属性在变量中可有可无。1234567891011121314151617interface Person &#123; name: string; age?: number;&#125;let tom: Person = &#123; name: 'tom'&#125;;//编译成功interface Person &#123; name: string; age?: number;&#125;let tom: Person = &#123; name: 'tom', age: 12&#125;;//编译成功 注意：此时仍不允许添加未定义属性，即：不能多 任意属性任意属性，即变量可有任意的属性，且一旦定义了任意属性，那么确定属性和可选属性都必须是它的子属性：123456789101112131415161718192021222324interface Person &#123; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; name: 'Tom', gender: 'male'&#125;;//编译成功interface Person &#123; name: string; age?: number; [propName: string]: string;&#125;let tom: Person = &#123; name: 'Tom', age: 25, gender: 'male'&#125;;//编译失败 只读属性有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性：12345678910111213interface Person &#123; readonly id: number; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; id: 89757, name: 'Tom', gender: 'male'&#125;;tom.id = 9527;//编译错误 注意：只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：123456789101112interface Person &#123; readonly id: number; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; name: 'Tom', gender: 'male'&#125;;tom.id = 89757;//编译错误 数组的类型在TS中，数组的类型有多种定义方式，比较灵活。 类型+方括号表示法最简单的办法是通过类型+方括号来表示数组： 1let fibonacci: number[] = [1, 1, 2, 3, 5]; 数组的项中不允许出现其他的类型。12let fibonacci: number[] = [1, '1', 2, 3, 5];//编译错误 数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：123let fibonacci: number[] = [1, 1, 2, 3, 5];fibonacci.push('8');//编译错误 数组泛型表示法也可以使用数组泛型（Array Generic） Array&lt;elemType&gt;来表示数组：1let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5]; 泛型到后面会再展开描述 用接口表示数组接口也可以用来表示数组：1234interface numArray &#123; [index: number]: string&#125;let arr: numArray = ['a', 'b', 'c']; numArray表示：只要index的类型是number，那么值的类型必须是string。 函数的类型在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）。一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到。 函数声明1234function sum(x: number, y: number): number &#123; return x + y;&#125;sum(1, 2); 注意，输入多的或少的参数，是不被允许的：12345678910function sum(x: number, y: number): number &#123; return x + y;&#125;sum(1, 2, 3);//编译错误function sum(x: number, y: number): number &#123; return x + y;&#125;sum(1);//编译错误 函数表达式如果我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样：123let mySum = function(x: number, y: number): number &#123; return x + y;&#125; 这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样：123let mySum: (x: number, y: number) =&gt; number = function(x: number, y: number): number &#123; return x + y;&#125; 注意不要混淆了TS中的 =&gt; 和ES6中的 =&gt;。在 TypeScript 的类型定义中，=&gt;用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型，在 ES6 中，=&gt; 叫做箭头函数，应用十分广泛。 用接口定义函数形状可以使用接口的方式来定义一个函数需要符合的形状：1234567interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; return source.search(subString) !== -1;&#125; 可选参数前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？与接口中的可选属性类似，我们用 ? 表示可选的参数：123456789function buildName(firstName: string, lastName?: string) &#123; if (lastName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return firstName; &#125;&#125;let tomcat = buildName('Tom', 'Cat');let tom = buildName('Tom'); 注意：可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必须参数了：12345678910function buildName(firstName?: string, lastName: string) &#123; if (firstName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return lastName; &#125;&#125;let tomcat = buildName('Tom', 'Cat');let tom = buildName(undefined, 'Tom');//编译错误 参数默认值在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数：12345function buildName(firstName: string, lastName: string = 'Cat')&#123; return firstName + ' ' + lastName;&#125;let tomcat = buildName('Tom', 'Cat');let tom = buildName('Tom'); 此时就不受「可选参数必须接在必需参数后面」的限制了：12345function buildName(firstName: string = 'Tom', lastName: string) &#123; return firstName + ' ' + lastName;&#125;let tomcat = buildName('Tom', 'Cat');let cat = buildName(undefined, 'Cat'); 剩余参数ES6中，可以使用...rest的方式获取函数中的剩余参数（rest参数）：1234567function push(array, ...items)&#123; item.forEach(function(item)&#123; array.push(item); &#125;)&#125;let a = [];push(a, 1, 2, 3); 注意，rest 参数只能是最后一个参数]]></content>
      <tags>
        <tag>知识积累</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《TypeScript学习笔记-基础一》]]></title>
    <url>%2F2018%2F01%2F03%2F%E3%80%8ATypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E4%B8%80%E3%80%8B%2F</url>
    <content type="text"><![CDATA[17年前端的发展逐渐趋于理性，由盲目的追求广度转向探求语言和框架的深度。TS作为JS的超集，日后定会成为前端的必备技能之一，以前对ts只是懵懵懂懂的，不成体系，不求细节，趁着最近公司要上Angular的项目，抓紧时间系统学习一下TS的相关知识，该系列博客作为日后查漏补缺之用，内容来源于xcatliu:TypeScript入门教程。 什么是TypeScript?TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub 上。它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。同时TypeScript 编译工具可以运行在任何服务器和任何系统上。 TS编译使用npm全局安装typescript1$ npm install -g typescript 新建hello.ts文件，在当前目录下执行1$ tsc hello.ts 即可编译 原始数据类型JavaScript的原始类型包括：boolean,number,string,null,undefined及ES6中的新类型Symbol。 布尔值 12let boo: boolean = false;//编译通过 注意，使用构造函数Boolean创造的对象不是布尔值，new Boolean()返回的是一个Boolean对象12let newboo: boolean = new Boolean(1);//编译失败 以下两种调用方式可行：12let newboo: Boolean = new Boolean(1);let newboo: boolean = Boolean(1); 总结：js的原始类型基本上都遵循以上规则（除null和undefined之外） 数值 12345678let decLiteral: number = 6;let hexLiteral: number = 0xf00d;// ES6 中的二进制表示法let binaryLiteral: number = 0b1010;// ES6 中的八进制表示法let octalLiteral: number = 0o744;let notANumber: number = NaN;let infinityNumber: number = Infinity; 编译结果：12345678var decLiteral = 6;var hexLiteral = 0xf00d;// ES6 中的二进制表示法var binaryLiteral = 10;// ES6 中的八进制表示法var octalLiteral = 484;var notANumber = NaN;var infinityNumber = Infinity; 总结：其中 0b1010 和 0o744 是 ES6 中的二进制和八进制表示法，它们会被编译为十进制数字。 字符串 12345let myName: string = 'Tom';let myAge: number = 20;//模板字符串let sentence: string = `my name is $&#123;myName&#125;, my age is $&#123;myAge&#125;`; 编译结果：1234var myName = 'Tom';var myAge = 25;// 模板字符串var sentence = "my name is " + myName + ",\nmy age is " + myAge; 空值 js没有空值（Void）的概念，在ts中，用void表示没有任何返回值的函数：123function getName(): void &#123; alert('liyang');&#125; 申明一个void类型的变量没有什么用，因为只能赋值给他undefined和null:1let test: void = undefined; Null和Undefined 在TS中，可以使用null和undefined来定义这两个原始的数据类型：12let u: undefined = undefined;let n: null = null; undefined类型的变量只能被赋值为undefined, null类型的变量只能被赋值为null注意：与void区别是：undefined和null是所有类型的子类型，也就是说undefined类型的变量可赋值给number类型的变量：123456let num: number = undefined;//编译通过let u: undefined;let num: number = u;//编译通过 而void类型不能赋值给number类型的变量：123let u: void;let num: number = u;//编译错误 任意值任意值用来表示允许赋值为任意类型。 普通类型在赋值过程中不允许改变类型： 123let number: string = 'three';number = 12;//编译错误 但若是any类型，则允许赋值时改变类型：123let number: any = 'three';number = 34;//编译成功 在任意值上访问任何属性都是允许的： 12let anything: any = 'liyang';console.log(anyThing.myName); 也可以调用任何方法：123let anything: any = 'liyang';anything.setName('tom');anything.setName('tom').sayHello(); 注：声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。 变量如果在声明时未指定其类型，则会被识别未任意值类型：12345let something;something = 'seven';something = 7;something.setName('Tom'); 类型推论如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。 123let number = 'three';number = 12;//编译报错 以上等价于：12let number: string = 'three';number = 12; 注：如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：1234let number;number = 'three';number = 13;//编译成功 联合类型 联合类型表示取值可以是多种类型中的一种 123456789let num: string | number;num = 'three';num = 123;//编译成功let num: string | number;num = 'three';num = ture;//编译错误 访问联合类型的属性或方法当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法： 123456789function getLength(something:string | number): number&#123; return something.length;&#125;//编译错误，number没有length属性function getLength(something:string | number): number&#123; return something.toString();&#125;//编译成功 联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型： 12345let num: string | number;num = 'three';console.log(num.length); // 成功，返回5num = 123;console.log(num.length); // 错误 第四行的 num 被推断成了 number，访问它的 length 属性时就报错了。]]></content>
      <tags>
        <tag>知识积累</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《微信小程序开发之自定义轮播dot》]]></title>
    <url>%2F2017%2F12%2F15%2F%E3%80%8A%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AE%E6%92%ADdot%E3%80%8B%2F</url>
    <content type="text"><![CDATA[概述小程序内置了swiper组件，组件的dots默认为黑灰色的，简单的使用还可以，但是无法满足我们更深入的需求，改变一下样式、交互效果之类时就需要自定义dots。 解决方式首先将swiper的indicator-dots属性设为false，接下来直接贴代码123456789101112131415&lt;!-- index.html --&gt;&lt;view class='swiper-container'&gt; &lt;swiper class="swiper" indicator-dots="&#123;&#123;false&#125;&#125;" autoplay="&#123;&#123;true&#125;&#125;" interval="3000" circular="&#123;&#123;true&#125;&#125;" bindchange="swiperChange"&gt; &lt;block wx:for="&#123;&#123;banners&#125;&#125;" wx:key="&#123;&#123;item.id&#125;&#125;"&gt; &lt;swiper-item&gt; &lt;image src="&#123;&#123;item.images&#125;&#125;" class="slide-image" mode="aspectFill"/&gt; &lt;/swiper-item&gt; &lt;/block&gt; &lt;/swiper&gt; &lt;view class="dots"&gt; &lt;block wx:for="&#123;&#123;banners&#125;&#125;" wx:key="&#123;&#123;item.id&#125;&#125;"&gt; &lt;view class="dot &#123;&#123;index == current ? 'active' : ''&#125;&#125;"&gt;&lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; 12345678&lt;!-- index.css --&gt;.swiper-container&#123;position: relative;&#125;.swiper-container swiper&#123;height: 350rpx;width: 100%;&#125; .swiper-container swiper image&#123;width: 100%;height: 100%;display: block&#125;/* 轮播点样式 */.swiper-container .dots&#123;position: absolute;left: 0;right: 0;bottom: 18rpx;display: flex;justify-content: center;&#125;.swiper-container .dots .dot&#123;margin: 0 6rpx;width: 12rpx;height: 12rpx;background: #fff;border-radius: 8rpx;transition: all .6s;&#125;.swiper-container .dots .dot.active&#123;width: 26rpx;background: #fd2c4e;&#125; 12345678910111213141516171819202122232425&lt;!-- index.js --&gt;Page(&#123; data: &#123; banners: [], current: 0 &#125;, onLoad: function()&#123; //获取主页banner图 wx.request(&#123; url: 'https://xxxx.xxxx', method: 'GET', success: res =&gt; &#123; _this.setData(&#123; banners: res.data &#125;) &#125; &#125;) &#125;, // 轮播图切换事件 swiperChange: function (e) &#123; this.setData(&#123; current: e.detail.current &#125;) &#125;,&#125;)]]></content>
      <tags>
        <tag>工作积累</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《微信小程序开发之new Date()参数格式问题》]]></title>
    <url>%2F2017%2F12%2F15%2F%E3%80%8A%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8Bnew-Date-%E5%8F%82%E6%95%B0%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98%E3%80%8B%2F</url>
    <content type="text"><![CDATA[概述小程序开发中遇到时间对比的情况，根据接口返回的时间来判断订单是否过期。后台返回的时间是这样的字符串格式: 2017-12-15 20:30:47,以下为比较代码123456let now_time = new Date();let end_time = new Date(res.data.end_time);if(now_time.getTime() &gt; end_time.getTime())&#123; &lt;!-- 结束时间小于当前时间 --&gt; ...&#125; 在微信开发者工具中进行调试运行没有问题，判断是正确的。但是到真机上调试判断却没有生效，尝试了多次，才发现微信对于2017-12-15这样的格式可以正常识别，但是加上时间就会出现无法识别的问题。故对时间格式进行了一步转化，转为yyyy/mm/dd hh:mm:ss格式。123456let now_time = new Date();let end_time = new Date(res.data.end_time.replace(/-/g, '/'));if(now_time.getTime() &gt; end_time.getTime())&#123; &lt;!-- 结束时间小于当前时间 --&gt; ...&#125; 再次测试，开发工具和真机调试都可以正常进行判断。 基于微信web页面的开发，此问题一样存在]]></content>
      <tags>
        <tag>工作积累</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《微信小程序开发之异步转同步》]]></title>
    <url>%2F2017%2F12%2F12%2F%E3%80%8A%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%BD%AC%E5%90%8C%E6%AD%A5%E3%80%8B%2F</url>
    <content type="text"><![CDATA[问题概述基于小程序request请求是异步的特性，app.js onLaunch()中的请求与index.js onLoad()中的请求是同时进行的，导致onLoad()中如果有基于onLaunch()返回的数据的请求，会有报错，导致onLoad()中request请求的数据“第一次”无法正常获取。 我的小程序中所有的requset请求都需要在header中带着用户唯一的token进行发起，而token是在app.js onLaunch()中的wx.login()返回中获取到的（由code到后台换取），之后通过wx.setStorageSync(&#39;token&#39;, res.data)存到小程序中。要解决问题，就需要解决request请求异步的问题，而且是在两个js文件之间。 使用Promise()稍微说一下promise12345678910111213var promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);promise.then(function(value) &#123; // success&#125;, function(value) &#123; // failure&#125;); Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 方法和 reject 方法。 如果异步操作成功，则用 resolve 方法将 Promise 对象的状态，从「未完成」变为「成功」（即从 pending 变为 resolved）； 如果异步操作失败，则用 reject 方法将 Promise 对象的状态，从「未完成」变为「失败」（即从 pending 变为 rejected）。 接下来在小程序中引入promise库。到bluebird官网中下载压缩版本的promise库。直接打开bluebird.core.min.js，复制代码。 Bluebird is a fully featured JavaScript promises library with unmatched performance.小程序内新建一个promise.js文件，将bluebird.core.min.js中的代码复制进去。在app.js中通过require引入：12&lt;!-- app.js --&gt;const Promise = require('units/promise.js'); 这样就可以在小程序内使用promise了，该库大小大概在64kb左右，可以接受。接下来直接贴代码：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- app.js --&gt;App(&#123; onLaunch: function()&#123; &lt;!-- 调整代码结构，原本在此进行的wx.login操作放到下面去 --&gt; ... &#125;, //登录，获取token getToken: function()&#123; let _this = this; return new Promise(function(resolve, reject)&#123; wx.checkSession(&#123; success: function (res) &#123; resolve(res); &#125;, fail: function (res) &#123; wx.login(&#123; success: res =&gt; &#123; // 发送 res.code 到后台换取 openId, sessionKey, unionId if (res.code) &#123; wx.request(&#123; url: CONFIG.loginUrl, data: &#123; code: res.code &#125;, header: &#123; 'shopId': CONFIG.shopId &#125;, method: 'POST', success: res =&gt; &#123; wx.setStorageSync('token', res.data); //储存返回的token resolve(res); &#125; &#125;) &#125; else &#123; console.log('获取用户登录态失败！' + res.errMsg); reject('error'); &#125; &#125; &#125;) &#125; &#125;) &#125;) &#125;&#125;) 接下来在index.js中处理12345678910111213141516171819202122232425262728const app = getApp();Page(&#123; onLoad: function()&#123; let token = wx.getStorageSync('token'); if (token == '')&#123; //第一次登录，获取登录状态 app.getToken().then(function (res) &#123; _this.getData(); //此时token必然已经获取到，且getData()在此时才会执行 &#125;) &#125;else&#123; //有token的情况直接获取数据 _this.getData(); &#125; &#125;, //获取数据 getData: function()&#123; wx.request(&#123; header: &#123; 'token': wx.getStorageSync('token') &#125;, url: 'https://xxxxx.xxxxx', method: 'GET', success: res =&gt; &#123; console.log(res); &#125; &#125;) &#125;&#125;) 这时候清除一下开发工具的缓存，再次编译页面，打开调试面板的network，可以看到index.js中的wx.request请求是在wx.login()的success后才开始的，这样就达到了我们的目的，问题解决。]]></content>
      <tags>
        <tag>工作积累</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《微信小程序开发之路由思考》]]></title>
    <url>%2F2017%2F12%2F04%2F%E3%80%8A%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF%E7%94%B1%E6%80%9D%E8%80%83%E3%80%8B%2F</url>
    <content type="text"><![CDATA[路由概述小程序框架使用栈的形式来维护了所有展示页面，当页面进行打开、前进、返回、关闭、tab切换等操作时，都是页面的不断出栈进栈的过程。当然这个栈的层级是有数量限制的，官方规定最多5层页面，多了之后将无法打开下一级的页面。需要说明一点的是官方提供了navigator这个组件和wx.navigateTo()、wx.redirectTo()等多个方法来供开发者来实现实现的页面的跳转，重定向。而且两者是有对应关系的，下面来简单描述一下，更详细的讲解请查阅官方API文档。 导航API方法小程序官方提供了5种导航方式，其中4种都带有丰富的回调接口满足开发者的使用。 wx.navigateTo(object):保留当前页面（栈），跳转到另外某个页面（新进栈）。注意当前页面不会出栈，下个页面使用wx.navigateBack可以返回到该页面。 123456wx.navigateTo(&#123; url: 'test?id=1', //不能是tabBar里定义过的链接 success: function()&#123; ... &#125;, fail: function()&#123; ... &#125;, complete: function()&#123; ... &#125;&#125;) wx.redirectTo(object):关闭当前页面（出栈），跳转到另外某个页面（新进栈）。 123456wx.redirectTo(&#123; url: 'test?id=1', //不能是tabBar里定义过的链接 success: function()&#123; ... &#125;, fail: function()&#123; ... &#125;, complete: function()&#123; ... &#125;&#125;) wx.reLaunch(object):关闭其他所有栈内的页面，打开到某个页面（唯一在栈内页面）。调用该方法，左上角返回箭头也会消失。 123456wx.reLaunch(&#123; url: 'test?id=1', success: function()&#123; ... &#125;, fail: function()&#123; ... &#125;, complete: function()&#123; ... &#125;&#125;) wx.switchTab(object): 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 123456wx.reLaunch(&#123; url: 'test?id=1', //需在app.json中定义过 success: function()&#123; ... &#125;, fail: function()&#123; ... &#125;, complete: function()&#123; ... &#125;&#125;) wx.navigateBack(object):关闭当前页面，返回上一页面或多级页面。可通过getCurrentPages()获取当前的页面栈，决定需要返回几层。接受唯一参数delta 123wx.navigateBack(&#123; delta: 2&#125;) wx.navigateTo 和 wx.redirectTo 不允许跳转到 tabbar 页面，只能用 wx.switchTab 跳转到 tabbar 页面 navigator组件这个组件或者说标签是用在 .wxml文件中的，其实就相当于一个带href属性的a标签。1&lt;navigator url="/page/index/index" open-type="navigate" hover-class="other-navigator-hover"&gt;切换 Tab&lt;/navigator&gt; 最常用的属性有：url指向要跳转的链接；open-type定义跳转的方式，这个马上下面介绍；hover-class规定点击该标签时的样式类。open-type有5个有效值： navigate:对应于wx.navigateTo() redirect:对应wx.redirectTo() switchTab:对应wx.switchTab() reLanch:对应wx.reLaunch navigateBack:对应wx.navigateBack 实际使用navigator组件和wx.navigateTo()等方法其实是一样的，需要具体情况具体分析选择，做几个页面其实基本上就可以掌握用法。我这次做到的项目中，具体是这样的一种页面层级关系： 123456&lt;!-- tab1首页 --&gt;index ==&gt; goodsList ==&gt; goodsInfo ==&gt; buy(redirectTo) ==&gt; orderList(1) (2) (3) (4)&lt;!-- tab2我的 --&gt;userInfo ==&gt; orderList(1) (2) 其中goodsInfo页面有一个直达orderList的按钮，tabBar中我的页面有个人订单项，可以查看我的订单。有一个需求是在orderList页面中实现点击商品跳转至对应的goodsInfo页面，这样其实形成了一种闭环的页面跳转，如果直接使用wx.navigateTo()方法，则新打开的goodsInfo页面便会是第五层，其中的任何链接将无法再点击打开；如果使用wx.redirectTo()打开，则用户无法通过右滑再次返回orderList页面，用户体验不好。思考最后，最终的解决方案是在orderList页中为商品绑定点击事件，通过getCurrentPages()获取当前层级，若层级大于2，则return掉点击事件，同时新做了一个订单详情的页面作为备选方案，可以查看订单的一些信息；若层级等于2，则点击商品跳转至对应的商品详情goodsInfo页中。 12345678toGoodsInfo: function()&#123; let pages = getCurrentPages(); if(pages.length == 2)&#123; wx.navgateTo(&#123; url: `/pages/goodsInfo/goodsInfo?id=$&#123;this.goods.id&#125;` &#125;) &#125;&#125;]]></content>
      <tags>
        <tag>工作积累</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《微信小程序开发之自定义tips组件》]]></title>
    <url>%2F2017%2F12%2F03%2F%E3%80%8A%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89tips%E7%BB%84%E4%BB%B6%E3%80%8B%2F</url>
    <content type="text"><![CDATA[目前小程序官方提供的交互反馈组件只有Toast、Loading、Modal这3种。 wx.showToast()默认有success和loading两种图标可选，也可以自定义图标，设置好duration持续时间后可自动消失，或者主动调用wx.hideToast()来关闭。title设置过长会被隐藏部分内容。12345wx.showToast(&#123; title: '成功', icon: 'success', duration: 2000&#125;) wx.showLoading()loading组件无图标可选，只有转圈圈的图标可用，而且必须调用wx.hideLoading()来关闭。同样title设置过长文字会被隐藏。12345wx.showLoading(&#123; title: '加载中',&#125;)...wx.hideLoading() wx.showModal()Modale组件功能就更丰富了一些。可以设置title、content、confirm和cancel按钮的内容和颜色，还有各自的回调函数等等。title和content设置过长也会被完整显示。在上一篇的《微信小程序开发之授权逻辑》中就用到了这种弹窗来让用户进行选择操作。1234567891011wx.showModal(&#123; title: '提示', content: '这是一个模态弹窗', success: function(res) &#123; if (res.confirm) &#123; console.log('用户点击确定') &#125; else if (res.cancel) &#123; console.log('用户点击取消') &#125; &#125;&#125;) 不过在开发过程中，总有一些提示性的信息需要一个更舒服的提示组件来展示。比如提示用户电话号码输入错误、搜索内容不能为空、无法打开地图等等。这些提示如果用上述的3种组件来展示，会很难受，也不优美，所以需要我们自己去开发一个新的提示组件，来满足我们项目的需求。 个人提示组件myTopTips网上其实有很多大厂开发的微信组件ui，可以直接集成到项目中，或者只提取出我们需要的部分，以下我使用的topTips组件来源于有赞开源的组件，zanui-weapp，基于其topTips组件，我将其样式做了修改，添加了3种不同的提示类型：success、warning、error，基本上满足了我在项目中的使用。项目中新建一个page，命名为mytips，记得将其引用路径从app.json中删除，不然会有很多错误。参看我的另一篇博客《微信小程序开发之踩坑记录》。然后编辑mytips.js文件12345678910111213141516171819202122232425262728293031323334353637&lt;!-- mytips.js文件 --&gt;module.exports = &#123; showMyTips(content = '', icon = '', options = &#123;&#125;) &#123; let MyTips = this.data.MyTips || &#123;&#125;; // 如果已经有一个计时器在了，就清理掉先 if (MyTips.timer) &#123; clearTimeout(MyTips.timer); MyTips.timer = undefined; &#125; if (typeof options === 'number') &#123; options = &#123; duration: options &#125;; &#125; // options参数默认参数扩展 options = Object.assign(&#123; duration: 3000 &#125;, options); // 设置定时器，定时关闭topTips let timer = setTimeout(() =&gt; &#123; this.setData(&#123; 'MyTips.show': false, 'MyTips.timer': undefined &#125;); &#125;, options.duration); // 展示出topTips this.setData(&#123; MyTips: &#123; show: true, content, icon, options, timer &#125; &#125;); &#125;&#125;; 接下来编辑wxml和wxss文件12345678&lt;!-- mytips.wxml文件 --&gt; &lt;template name='mytips'&gt; &lt;view class="mytips &#123;&#123; MyTips.show ? 'mytips-show' : '' &#125;&#125;"&gt; &lt;view class='mytips-box'&gt; &lt;text class='mytips-&#123;&#123;MyTips.icon&#125;&#125;'&gt;&#123;&#123; MyTips.content&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt; 123456789&lt;!-- mytips.wxss文件 --&gt;&lt;!-- 图标使用了base64的背景图 --&gt;.mytips&#123;position:fixed;top:10rpx;left:0;right: 0;z-index: 999;display: flex;justify-content: center;-webkit-transform:translateZ(0) translateY(-150%);transition:all .3s ease&#125;.mytips-show&#123;-webkit-transform:translateZ(0) translateY(0)&#125;.mytips .mytips-box&#123;padding: 12rpx 28rpx;background: #fff;box-shadow:0 2px 8px rgba(0,0,0,.2);border-radius: 8rpx;height:36rpx;&#125;.mytips .mytips-box text&#123;padding-left:40rpx; font-size: 24rpx;line-height: 36rpx;height: 36rpx;display: block&#125;.mytips .mytips-box text.mytips-success&#123;background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAADh0lEQVRIia2WPYhcVRTHf+fc92ZXO4PBRkgsYiOaQIxEEXaJ4LIrCTbpIgQJiYQtLaIgBCstbCyCBsRCbbYJISQbP4gs+AEaggS2iIKspQEVETTz3rvnbzGzyc5zZrNj5hQP3rn3/H/349x7j00vA4CZY14CggiyQd3JlE2BZz+gFPOG7THZLmBbL4rfZfpJ6AfLvhwprtRFQ1klkgB3wFDUSNHjjAYKJTuZwk8a9phhCDHM1tuEVrPHGcs6k2RbA0oC6VGMs25phpGYYeDeN5RXEMcx+9FsEOiDIQJYMPfrZj6jMWDr0UKY+Yy5XwcWaCm0gMyZ2UVgagzOKJvqa82NAu4EX54AqGW+3NPu/3WnoeoY5sUSyCaBMBl3hGTmxVLVMbrT4Erg+FHH900K1njzeiaeA/4CcHyf40eVwMovCsrwNcN2jJMgw8zldFP1du35VKcpKfCbwHYDhH6pPXZ6yj5r+ARgRjdV79RFPlU0hSfsG4Pt0MtTw3ek7LOuFAftHmkmo0r1W3XKrxZVaR2lrx17WgN9QCkOeor0ZNwD0TCyxwdVmV9D0In0lRn724phIkXa68CO/w+DkD6uLR9DMB3leTOe2WT4DzvwYMv5pyz2GizaJqekB+PDypuXcspM1eX5IqdD2ny1HiqGOLPgWmNxzbHHHTvRlliHdb15OcrMVFOeK6M4FBabwQCSA7+1nNtc6dtMwz9F9UqWPt04TwMy+uTWbVhxrszFi1uAAfzqwFrba7C/UPoIoPGYB1bXoULLQkfcxVRTLI0BA1jz7Pmqt/ZKCCcduS933nRQtjgg1AhdDbSQMKZz+V6Ri8NbzXCXkT1fc8t+YVRuJPkbKfzYrdTcrFLzhIlnvXdLnhWcuEuCDE7CwLJfuOvV5jL+LqrnMX1+f90hTO+DHd8yid6+377a6k5DlfLpjff74MjEVBQXy5wOC94dF9YDGlXKp+tOg9mXYGFM5/I7sKEvhvXIjLOErWF/fyvVT8k1UNPsNO/8PKk38Y4ZiuoRKdZg8MVfg1iYLAwg5thw9No1zWVJLwDdCZC6SPPAZxudLaABXJJitxQrxqhUGm5Gv0ZVrEixG7hMS6E9w16QdCMsZmtvFgOt0hcaDeq1BVqtvVkMi1mTbgzt+5/KWwIF2aFOmVL9Ut9iwbA9hu0CHujH/yH6pb78UqS4UltDmRMpAHNoFcL/AsvcwfKVBFWTAAAAAElFTkSuQmCC) no-repeat left center/28rpx 28rpx;&#125; .mytips .mytips-box text.mytips-warning&#123;background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAACRElEQVRIib3WT2sVZxTH8c95xpCWFhQVuilo6Z9dVUQQRBClatNFuyt05dK2vom8iuJWXGRtF9WWkGwtFFp1JdJE6KoLS7spGuc+x8Xca9Jrkju3cvODgZnnnPN8zzwzz3lO5JKXqhVJFCLxHPvI4oJqQTiBD3FwGPIXHkm/KW5HtaLFHIKanVMpm4zYFTjwbRZfCx+LzratRrb0IKrrGt9NC/xIuo7zOyAmaTXC1ZoejQPLK67hU+n+a8DgfKZ7uDRuGAdeCm5jfpfJ2kjHo3VGGuzi92bwIz7ZOrh1Sd/Lam1i7vyDAxLhb+yf4F+j+ADrUDzFBlkt7R63mSQaRTO8n6SS1ZINPKUYkFwRTvcEdtrpj90+xdPJFQOKeeyzONUE0yqHjHlKNs7h6AxxIx3Nxrli4PNeX+J1FRj4oihOzXQ5R0oUJwuO7AFupHcLDu8h8J1XS9ts1RQ82UPgnwWP9xD4uKh+mXJbdCdld9XeUYHq16Lx/ZTb4m2cxUm8NVWajVuRN8li3eyrzVpU7xfP0FqcabUpGFi0oTtkItzAzz3D2+BIdAWj7RVR3Y3qpqB4A3NE+Eq/nyAzNZka/Q6pNlpfqnTATa0nl3tMMCesCWtdqhOyYwF/jJ7LmHU50wKe9QBP0r+ZLmN56+B2pe2OcFxY/V+YrkddVh0Tfho371RLH0a6oLqGB1Pg7qm+iXRR+n3bfP7TCA+bvlHnnc+JZtjqp8+EY7pW/9Aw5Imu1b8v/BDVStYuPpNshm/V6upS8AJ22r+NeHvxEQAAAABJRU5ErkJggg==) no-repeat left center/28rpx 28rpx;&#125;.mytips .mytips-box text.mytips-error&#123;background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAACD0lEQVRIibWWz0tVQRTHP5NCJLoIqk3/RxBEUGKLQCjaFrgICWwhlBKC4KqNv/BHqzZFIChoi1qGC1dCLdpFi+CBYaKIiIqrOafFnZvXaaY743sNfLmPmXPO587c884co/w9yjlTPC4o9AI9wHXgKtBWMd8G1g2sKnwwsFPGMIHYaEBS6LzAoMCGgCZqX2FUoUsisWPAWwI/MkC+fgrcSQX2NQE6JYUndcBHrYJVoANBoMC1VsMq0B4f2Caw6Rl+FVg6A+CjwGdv7lCLbP+zu8GA44J7mRepMAszzud1YP1lCewQ2I8cxUgqtAIbjthYhcsI3K85/1EpAj1vAlaqH4E3CW8/5aDPAmtzsbWA3iPwLfX7iLcLC/MZMBXYQGAvJykcYM7Covs9lOovcITAUYaDWli2J3+n+RxfgYP2UEGvGca4Ag9cCt4I/xq5R6onR7pgAQuTGTs8ROB7JqyaNNMOOpEIbCDwNgEWTX0LUw46nQBcROBBDexVDFaxGXfQmRrgQwQ6Y5lqYVYSU9/CRM1OjxUulu1EKOCy1JS0AHTSxov3WPV6Oiew7Rl80YSyF9A7hU/e3N6p68ldUTfOEDxJCt2xFuPxf4A9rWui+lsIG/Djx9rEboFGE7CGwt2cvhQpOoFhgV8ZoC2BEYGOUFwFjAbqqzfXCdwDbgM3gSue+S6wBqwaWFE4gEibD/wGOu7Ykd5d0vYAAAAASUVORK5CYII=) no-repeat left center/28rpx 28rpx;&#125; 文件编辑完之后，就是页面的引用了，其实现在来看，引入自定义组件还是比较麻烦的一件事，每个用到的页面都需单个引入，异常麻烦。不过我现在也没有更好的解决方案，只能先这样使用了。假如我们要在index页面中使用这tips组件，则需要分别在index.wxml和index.js中引入该组件的内容，样式文件mytips.wxss直接放到了app.wxss中进行引入，所以该组件的样式会在所有小程序页面中覆盖到，建议取的class类名个性一点，防止影响页面样式。123&lt;!-- app.wxss文件中全局引入mytips.wxss样式 --&gt;@import "/component/mytips/mytips.wxss";... 123456&lt;!-- index.wxml中引入mytips的模板 --&gt;&lt;import src="path/to/component/mytips/mytips"/&gt;&lt;template is="mytips" data="&#123;&#123; MyTips &#125;&#125;"&gt;&lt;/template&gt;&lt;view class='container'&gt;...&lt;view&gt; 123456&lt;!-- index.js中需要这样引入，修改Page(&#123;&#125;)为如下，其他数据不会受到影响 --&gt;const MyTips = require('path/to/component/mytips/mytips');Page(Object.assign(&#123;&#125;, MyTips, &#123; data:&#123; &#125;, onLoad: function()&#123; &#125;&#125;)) 如上引入完毕后，在页面中要使用该tips提示时，只需在js方法中1234&lt;!-- 第二个参数可选为：success,warning,error；第三个参数为显示的时间 --&gt;showTips: function()&#123; this.showMyTips('这里填需要提示内容', 'warning', 2000);&#125; 最后的提示效果如下：还有一个success的样式没有截到（因为这个很少使用到，就不找了），为一个绿色背景的白色对勾图标。]]></content>
      <tags>
        <tag>工作积累</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《微信小程序开发之授权逻辑》]]></title>
    <url>%2F2017%2F11%2F25%2F%E3%80%8A%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E6%8E%88%E6%9D%83%E9%80%BB%E8%BE%91%E3%80%8B%2F</url>
    <content type="text"><![CDATA[微信可能是国内最注重用户体验的一款软件了吧，张小龙对于产品的把控及理念让人佩服不已。基于微信的小程序当然也不会放任开发者肆意去xx用户体验。小程序的授权最初搞的我头大，什么wx.authorize()、wx.getSetting()、wx.getUserInfo等等，什么时候该用什么方法调用，着实让我绕了半天。接下来总结一下我的开发心得及授权的小技巧。 wx.getUserInfo()&amp;&amp;wx.openSetting()小程序内获取用户信息的接口，一般进入小程序或者公众号都会有此提示：“是否同意xxx获取您的个人信息”。这个只会拿到用户的一些基本的非关键信息，如昵称、头像、性别、省市、国家、语言等。12345678910wx.getUserInfo(&#123; success: function(res) &#123; var userInfo = res.userInfo var nickName = userInfo.nickName var avatarUrl = userInfo.avatarUrl var gender = userInfo.gender //性别 0：未知、1：男、2：女 ... &#125;, fail: res =&gt; &#123;&#125;&#125;) 第一次调用这个接口会弹窗询问用户是否允许小程序获取个人信息，如果用户点击确定，则走success，下次用户再进来时不会弹窗，而是直接走success拿到用户信息。如果用户拒绝，那么就很蛋疼了，直接走fail，而且短期内就算调用wx.getUserInfo()接口，也不会再次弹窗询问，而是直接走fail。如果页面必须要获取用户的信息授权或者说用户第一次手抖点成了拒绝，那么如何再次调起弹窗获取用户授权呢？只使用wx.getUserInfo()是不行的，幸好小程序提供了一个wx.openSetting()，打开授权列表开关页，就好像手机设置中的通知授权开关页面一样，引导用户自己打开授权。所以我的思路是：先调用wx.getUserInfo()，如果用户点了确定，就直接走到success，拿到信息；如果点了拒绝，那么在fail接口中，使用wx.showModel()来询问用户是否要再次授权，确定的话就用wx.openSetting()打开setting页让用户自己打开授权，取消的话那就根据业务需要，展示相应的内容。代码如下：12345678910111213141516171819202122232425262728293031323334wx.getUserInfo(&#123; success: res =&gt; &#123; //用户点了允许，这里可以拿到用户的信息 &#125;, fail: res =&gt; &#123; //用户拒绝，再次弹窗询问是否要再次授权 wx.showModal(&#123; title: '温馨提示', content: '无法获取您的用户信息，点击确定重新进行授权，点击取消继续浏览', success: function (res) &#123; if (res.confirm) &#123; //点击了确定 wx.openSetting(&#123; //打开setting页面 success: res =&gt; &#123; //返回授权后的信息，再进行判断 if (res.authSetting['scope.userInfo']) &#123; //如果userInfo 的授权有了 wx.getUserInfo(&#123; //再次调用wx.getUserInfo拿用户数据，这次一定走success success: res =&gt; &#123; //拿到用户信息 &#125;, fail: res =&gt; &#123; console.log(res); //用户授权了却没拿到信息，不可知错误 &#125; &#125;) &#125; else &#123; //用户在setting页面依然没有打开授权，那么根据业务显示无用户信息的内容 &#125; &#125; &#125;); &#125; else if (res.cancel) &#123; //点击了取消，用户再次拒绝授权个人信息 //用户就是不给你授权，自己业务办法解决，要么就直接拒绝用户进入，要么显示其他内容 &#125; &#125; &#125;) &#125;&#125;) 这个逻辑也适用于获取用户定位信息的时候用，做地图定位导航的话是必须要有用户定位信息的，不给就不显示地图咯，给用户提示明白。这段逻辑代码就算用户第一次拒绝掉授权，再次进来页面的时候依然会弹窗提示用户自己去授权。]]></content>
      <tags>
        <tag>工作积累</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《微信小程序开发之踩坑记录》]]></title>
    <url>%2F2017%2F11%2F20%2F%E3%80%8A%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E3%80%8B%2F</url>
    <content type="text"><![CDATA[概述公司终于立项了微信小程序项目，估计是想从之前的backbone框架体系中逃脱出来，技术驱动一下业务的发展。前段时间都是在基于现有框架的基础上开发一下新的活动插件等等繁杂笨重的工作，某化妆品牌的828主题活动，双11主题活动插件等等，真是不想过多的聊这个。现在下定决心要做小程序，那就好好做一个产品出来。这篇blog会记录小程序开发中遇到的种种坑，不间断的更新。 路由tabBar小程序是一个多 tab 应用（可在底部或顶部有 tab 栏切换页面），可以在app.json中配置tabBar选项，最多5个，最少2个。例如：12345678910111213141516171819&lt;!-- app.json文件 --&gt;"tabBar": &#123; "color": "#666666", "selectedColor": "#ff0000", "list": [ &#123; "pagePath": "pages/index/index", "text": "首页", "iconPath": "images/home.png", "selectedIconPath": "images/home-actived.png" &#125;, &#123; "pagePath": "pages/userinfo/infolist/infolist", "text": "我的", "iconPath": "images/my.png", "selectedIconPath": "images/my-actived.png" &#125; ]&#125; 这些在小程序的官方文档中都能在例子来研究，不多讲。在开发中我一般喜欢将目前在构建的页面先配置到tabBar中，这样方便编译调试，问题来了，一次调试过程中，tabBar配置的页面死活无法通过点击tab图标打开，多次检查app.json文件，目标文件都未发现问题。后来多次检查实验才发现是某内页中使用了wx.navigate()方法指向了目标页，又在app.josn的tabBar配置中指向了这个目标页，导致无法通过tab图标打开页面。 不要同时通过wx.navigate()及wx.redirectTo与tabBar来指定同一页面，会导致点击tab图标无法打开目标页面。 下拉刷新回弹动画在ios端的问题做下拉刷新时，最初考虑到用户体验问题，在下拉刷新时先给一个wx.showLoading()正在加载的提示，之后获取数据后再调用wx.hideLoading()关闭loading框。12345678910111213// 下拉刷新onPullDownRefresh: function () &#123; this.refreshOrders();&#125;,refreshOrders: function()&#123; wx.request(&#123; success: res =&gt; &#123; ... wx.hideLoading(); wx.stopPullDownRefresh(); &#125; &#125;)&#125; 初期感觉不错，下拉时提示正在加载，数据有了之后关闭loading。但是在ios端下拉回弹的动画总是会过度回弹，导致顶部元素被遮挡，同时多次下拉会有几率触发页面卡下来的bug，本来以为是ios11的bug，但是发现其他小程序并未有此问题。后来思考了下，其实小程序的下拉刷新是有个顶部动画效果的，并不需要自己再做一层loading提示，去除wx.showLoading事件后，发现原来的下拉回弹bug也不见了，估计是两者共用导致的。 下拉刷新时不需要做wx.showLoading的提示，多此一举，反倒会触发ios的回弹动画bug 关于app.json中pages的配置问题先说结论 不要在app.json的pages中配置自定义模板及组件页面！！！这个坑我觉得属于不经意碰见了就会恶心一下午，碰不见的人就会觉得这bug很low，不值得一说。先看官方文档说明：接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息，数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改。注意，这里说的是页面，page。我想大多数开发者在用小程序的开发工具新建页面时，都会使用在目录中右键-新建-Page这种方式吧，一次建好4个同名的.js、.json、.wxml、.wxss文件，接下来就是写写写了，以这种方式新建page，小程序开发工具会自动帮你在app.json文件的Pages中帮你添加这个页面，很方便对不对。问题来了，一般的template不需要.js和.json文件，自定义的组件一般也不需要.json文件，坑就坑在如果你不注意开发工具自动帮你在Pages配置中添加了文件路径，那么你的组件和模板会一直报错，module xxxxx is not defined、xxx.js 出现脚本错误或者未正确调用 Page()等等，直接导致模板组件无效，页面无法编译等等一堆问题，定位bug所在会定位到想吐。这个坑，踩到真的很伤。]]></content>
      <tags>
        <tag>工作积累</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS随写：类型识别]]></title>
    <url>%2F2017%2F09%2F15%2FJS%E9%9A%8F%E5%86%99%EF%BC%9A%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[javascript是个弱类型的语言，工作中难免会遇到对数据的类型判断的问题（不过一般都是跟php确认一下，让他们返回正确的数据类型）。想了想还是把类型识别的常用方法总结一下，方便以后查阅。 typeof先说结论： 可以识别基本数据类型（Null除外），即Undefined,Boolean,Number,String 不能识别具体的对象类型（Function除外） 1234567891011121314typeof "tommmy"; //"string"typeof 123; //"number"typeof true; //"boolean"typeof undefined; //"undefined"typeof null; //"object"typeof &#123;name:"tommy"&#125;; //"object"typeof function()&#123;&#125;; //"function"typeof []; //"object"typeof /\d/; //"object"typeof new Date; //"object"//自定义对象function Person()&#123;&#125;;typeof new Person; // "object" instanceof先说结论： 可以判断内置对象类型 不能判断基本数据类型 可以判断自定义对象类型 12345678910111213141516['a','b'] instanceof Array; //true/\d/ instanceof RegExp; //true&#123;a:1&#125; instanceof Object; //truenew Date instanceof Date; //truenull instanceof Object; //false'abc' instanceof String; //false123 instanceof Number; //falsefunction man()&#123;age:20&#125;;function person()&#123;height:170&#125;;man.prototype = new person();man.prototype.constructor = man;var xiaoming = new man();xiaoming instanceof man; //truexiaoming instanceof person; //true Object.prototype.toString.call先说结论： 可以识别基本数据类型及内置的对象类型 不能识别自定义对象类型 123456789101112131415161718192021222324Object.prototype.toString.call("abc"); //[object String];Object.prototype.toString.call(123); //[object Number];Object.prototype.toString.call(null); //[object Null];//为方便测试，来一个测试方法function type(obj)&#123; return (Object.prototype.toString.call(obj).slice(8,-1));&#125;type(1); //"Number"type("abc"); //"String"type(true); //"Boolean"type(null); //"Null"type(undefined); //"Undefined"type(&#123;&#125;); //"Object"type([]); //"Array"type(new Date); //"Date"type(/\d/); //"RegExp"type(function()&#123;&#125;); //"Function"//自定义对象类型不能识别function abc(x)&#123; this.x = x;&#125;type(new abc(3)); //返回"Object"，应为Function abc? constructor原型链判断proto先说结论： 可以判断基本数据类型（Undefined和Null除外，因为他俩没构造函数） 可以判断内置对象类型 可以判断自定义对象类型首先我们可以在浏览器里打印 console.dir(new Number),查看其返回： 在其proto内看到其constructor为function Number(),故可以此来判断1234567891011121314151617181920212223242526"abc".constructor === String; //true(123).constructor === Number; //truetrue.constructor === Boolean; //truenew Date().constructor === Date; //true//方便测试，来个测试方法function constructorName(obj)&#123; //排除null和undefined return obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor.toString().match(/function\s*([^(]*)/)[1];&#125;constructorName(1); //"Number"constructorName("abc"); //"String"constructorName(true); //"Boolean"constructorName(null); //nullconstructorName(undefined); //undefinedconstructorName(&#123;&#125;); //"Object"constructorName([]); //"Array"constructorName(new Date); //"Date"constructorName(/\d/); //"RegExp"constructorName(function()&#123;&#125;); //"Function"//自定义对象类型可以判断function abc(x)&#123; this.x = x;&#125;constructorName(new abc11(3)); //"abc" 简单总结 对于除null之外的其他4个基本数据类型，可以使用typeof，方便快捷 如果想判断内置的对象类型，比如常见的Array,Object,正则日期等，直接是使用instanceof来判断 对于恼人的null来讲，只好请出Object.prototype.toString.call(null)来返回[object Null]来做精准判断了 还有用constructor来判断？看着就头大，不到万不得已，还是不用了吧]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>随写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js随写：正则表达式总结]]></title>
    <url>%2F2017%2F09%2F05%2Fjs%E9%9A%8F%E5%86%99%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概览正则表达式是个比较深的知识点，往深的说、细的说能写本书。近日看了一篇大神对正则的总结和介绍，自己对正则这块又有了一些新的理解和认识。刚巧自己也想把正则的一些知识点整理一下，汇总一下，方便自己以后查阅。这里基本上只写结论，例子会比较少，日后工作中多用，多写慢慢熟悉就好。 正则是匹配模式，要么匹配字符，要么匹配位置。这个理念很重要 匹配字符关键字：两种模糊匹配，字符组，量词 模糊匹配 横向匹配：正则可匹配的字符串长度不确定，使用量词来实现。如：{m,n},*,?,+ 1var reg = /ab&#123;2,3&#125;/g; //b重复2次到3次 纵向匹配：正则匹配字符串，具体到某一位字符时，可以是不确定的字符。使用字符组来实现。如：[abc]表示abc中的任意一个 123var regex = /a[123]b/g;var string = "a0b a1b a2b a3b a4b";console.log( string.match(regex) ); //["a1b", "a2b", "a3b"] 字符组字符组只能匹配当中的某一个字符，如[abc]表示a、b、c中的一个。 范围表示法。如：[a-z],[0-9],[a-m]等等。 排除字符法。在字符组内添加^符号，表示取反。如[^abc]表示除abc3个字符外的所有其他字符。 常见的简写形式： \d就是[0-9]，表示数字 \D就是[^0-9]，表示除数字外的任意字符 \w就是[a-zA-Z0-9_]，表示数字，大小写字母，下划线。也称单词字符 \W就是[^a-zA-Z0-9_]，表示除数字，大小写字母，下划线外的其他任意字符 \s就是[ \t\v\r\n\f]，包括空格、水平制表符、垂直制表符、回车符、换行符、换页符。 \S就是\s取反，非空白符号 .就是[^\n\r\u2028\u2029]，通配符，表示几乎任意字符，换行符、回车符、行分隔符和段分隔符除外如果要匹配任意字符，可以使用[\w\W]表示 量词{m,n}表示连续出现最少m次，最多n次{m,}表示至少出现m次{m}等价于{m,m}，出现m次?表示出现0次或1次*表示出现0次或任意多次+表示出现1次或任意多次 多选分支一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。具体形式如下：(p1|p2|p3)，其中p1、p2和p3是子模式，用|（管道符）分隔，表示其中任何之一。 匹配位置位置是相邻字符之间的位置。如’hello’,’h’和’e’之间就是一个位置在ES5中，共有6个锚字符：^（脱字符）匹配开头，在多行匹配中匹配行开头。$（美元符号）匹配结尾，在多行匹配中匹配行结尾。\b表示是单词边界，具体就是\w和\W之间的位置，也包括\w和^之间的位置，也包括\w和$之间的位置。\B就是\b的反面的意思，非单词边界。(?=p)其中p是一个子模式，即p前面的位置。(?!p)就是(?=p)的反面意思。 1234567891011121314151617181920var result = "hello".replace(/^|$/g, '#'); //把字符串的开头和结尾用"#"替换console.log(result); // =&gt; "#hello#"var result = "I\nlove\njavascript".replace(/^|$/gm, '@'); //多行匹配模式时，二者是行的概念console.log(result);// @I@// @love@// @javascript@var result = "[JS] Lesson_01.mp4".replace(/\b/g, '#'); // \b之间替换为#console.log(result); // =&gt; "[#JS#] #Lesson_01#.#mp4#"var result = "[JS] Lesson_01.mp4".replace(/\B/g, '#'); // 非\b之间替换为#console.log(result); // =&gt; "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4"var result = "hello".replace(/(?=l)/g, '#'); //l前面的位置console.log(result); // =&gt; "he#l#lo"var result = "hello".replace(/(?!l)/g, '#'); //非l前面的位置console.log(result); // =&gt; "#h#ell#o#" “hello”字符串等价于如下的形式:&quot;hello&quot; == &quot;&quot; + &quot;h&quot; + &quot;&quot; + &quot;e&quot; + &quot;&quot; + &quot;l&quot; + &quot;&quot; + &quot;l&quot; + &quot;o&quot; + &quot;&quot;;或者：&quot;hello&quot; == &quot;&quot; + &quot;&quot; + &quot;hello&quot; 对于位置的理解，我们可以理解成空字符””。字符之间的位置，可以写成多个。 正则分组，括号的作用 数据提取，进行替换操作 1234var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = "2017-06-12";console.log( string.match(regex) ); // =&gt; ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"] match返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本。（注意：如果正则是否有修饰符g，match返回的数组格式是不一样的，带g返回一个结果数组）。另外也可以使用正则对象的exec方法:1234var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = "2017-06-12";console.log( regex.exec(string) ); // =&gt; ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"] 进行过正则操作后，就可以使用$1-$9来提取分组数据12345678910var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = "2017-06-12";regex.test(string); // 正则操作即可，例如//regex.exec(string);//string.match(regex);console.log(RegExp.$1); // "2017"console.log(RegExp.$2); // "06"console.log(RegExp.$3); // "12" 反向引用：可以使用\1、\2、\3等来指代正则中的分组 123456789var regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/;var string1 = "2017-06-12";var string2 = "2017/06/12";var string3 = "2017.06.12";var string4 = "2016-06/12";console.log( regex.test(string1) ); // trueconsole.log( regex.test(string2) ); // trueconsole.log( regex.test(string3) ); // trueconsole.log( regex.test(string4) ); // false \1表示的引用之前的那个分组(-|\/|.)。不管它匹配到什么（比如-），\1都匹配那个同样的具体某个字符。 正则的方法String字符串方法 search split replace matchmatch返回结果的格式，与正则对象是否有修饰符g有关。 1234567var string = "2017.06.27";var regex1 = /\b(\d+)\b/;var regex2 = /\b(\d+)\b/g;console.log( string.match(regex1) );console.log( string.match(regex2) );// =&gt; ["2017", "2017", index: 0, input: "2017.06.27"]// =&gt; ["2017", "06", "27"] 没有g，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然后是整体匹配的第一个下标，最后是输入的目标字符串。有g，返回的是所有匹配的内容。 RegExp方法 test注：test整体匹配时需要使用^和$ execexec方法不管有没全局标志g,每次都只会返回一个匹配项。没有g，在同一字符串上多次调用exec()将始终返回第一个匹配项的信息；有g，每次调用exec()都会在字符串中继续查找新的匹配项，这是跟match方法明显的一个不同点。 123456789101112131415161718var string = "2017.06.27";var regex2 = /\b(\d+)\b/g;console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);// =&gt; ["2017", "2017", index: 0, input: "2017.06.27"]// =&gt; 4// =&gt; ["06", "06", index: 5, input: "2017.06.27"]// =&gt; 7// =&gt; ["27", "27", index: 8, input: "2017.06.27"]// =&gt; 10// =&gt; null// =&gt; 0 正则修饰符 g 全局匹配，即找到所有匹配的，单词是global i 忽略字母大小写，单词ingoreCase m 多行匹配，只影响^和$，二者变成行的概念，即行开头和行结尾。单词是multiline 本文基本上是基于掘金大神@老姚发布的正则火拼系列文章而来，我自己精简了一些内容，挑选了一些我目前能看懂希望掌握的知识点。原文还涉及许多正则的深入知识，待以后工作中接触后再逐步学习。文章传送门：JS正则表达式完整教程（略长）]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>随写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ckeditor编辑器视频插入及右键事件处理]]></title>
    <url>%2F2017%2F08%2F27%2Fckeditor%E7%BC%96%E8%BE%91%E5%99%A8%E8%A7%86%E9%A2%91%E6%8F%92%E5%85%A5%E5%8F%8A%E5%8F%B3%E9%94%AE%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[开场扯淡上次聊了聊ckeditor编辑器实例化及自定义图片上传功能的事儿，今天来说一些杂七杂八的优化及自定义视频插入的小功能。 右键菜单事件其实ckeditor第四版开始有了右键菜单事件，即在编辑器内右键图片，文本等，会弹出简单的编辑菜单，如复制，粘贴，剪切，编辑图片等等。初衷其实是好的，可是我就是喜欢简洁一些，傻瓜式操作。不过图片的右键编辑功能其实可以保留，方便直接右键编辑现有图片。记得上一篇中的注册右键事件吗？123456789// 注册右键菜单if ( editor.contextMenu ) &#123; editor.addMenuGroup( 'oss'); editor.addMenuItem( 'image', &#123; label: '修改图片', //右键菜单名称 command: 'ossupload', //执行的命令 group: 'oss' &#125; );&#125; 右键之后直接打开弹窗进行编辑即可。为了隐藏或者说取消ckeditor编辑器的默认右键事件，我们在config.js内这么写了一句：1CKEDITOR.config.menu_groups = ''; //编辑器内的右键菜单设为空。搜索关键字menuitem，查看源码 就是直接将右键菜单事件清空，使用我们自定义的右键菜单事件。参看源码：menuitem 自定义iframe插入视频插入第三方的视频链接也是编辑器常用的一个功能。可惜一个挺简单的功能又让官方搞的很复杂，让人看着就不想使用。同样是发挥自定义精神，我自己做了一个iframe的插入功能。 组件的文件结构同上一篇的oss上传，简单起见就不传图了，代码模拟下 1234567myiframe...dialogs......myiframe.js...images......xxx.jpg......xxx.png...plugin.js 先看最终效果： 直接插入视频网站的链接，可以自定义视频宽高百分比，同样基于rem的等比例。先定义plugin.js 123456789101112131415( function() &#123; CKEDITOR.plugins.add( 'myiframe', &#123; init: function( editor ) &#123; editor.addCommand('iframeup', new CKEDITOR.dialogCommand('iframeup')); editor.ui.addButton('myiframe', &#123; label: '插入视频', icon: 'plugins/myiframe/images/myiframe.png', command: 'iframeup' &#125;); CKEDITOR.dialog.add( 'iframeup', this.path + 'dialogs/myiframe.js' ); &#125;, afterInit: function( editor ) &#123;&#125; &#125; );&#125; )(); 接着是弹窗dialogs/myiframe.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081CKEDITOR.dialog.add( 'iframeup', function( editor ) &#123; // 视频提示文字 var remindHtml = new CKEDITOR.template( '&lt;p&gt;注：视频的高度和宽度为选填，默认宽度100%，高度是屏幕宽度的80%，&lt;/p&gt;'+ '&lt;p&gt;一般不会出现视频显示不完整的情况，请依据实际情况调整。&lt;/p&gt;' ).output(); return &#123; title: '插入视频', width: 360, minHeight: 200, contents: [ &#123; id: 'iframe', label: '插入视频', elements: [ &#123; id: 'source', label: '请输入视频的URL', type: 'text', validate: function() &#123; //简单的链接验证 if ( this.getValue() != '' &amp;&amp; this.getValue().indexOf('http') == -1 ) &#123; alert( 'url链接错误，请重新输入' ); return false; &#125; &#125; &#125;, &#123; type: 'hbox', //系统自定义水平box widths: [ '50%', '50%'], //分左右两部分，各50%宽 children: [ &#123; type: 'text', //系统自定义input，type=text width: '80%', //左宽度的80%，即宽度的50%*80% id: 'width', //取值用到的id label: '宽度', 'default': '100%', //默认input的value值 validate: function() &#123; //验证只能填入百分数 var reg = /^[0-9]+%$/; if (!reg.test(this.getValue())) &#123; alert( '请输入正确的百分数宽度' ); return false; &#125; &#125; &#125;, &#123; type: 'text', //同上 id: 'height', width: '80%', label: '高度', 'default': '80%', validate: function() &#123; var reg = /^[0-9]+%$/; if (!reg.test(this.getValue())) &#123; alert( '请输入正确的百分数高度' ); return false; &#125; &#125; &#125; ] &#125;, &#123; type: 'html', html: remindHtml //自定义说明文档 &#125; ] &#125; ], onOk: function () &#123; //确定时传值 var isrc = this.getValueOf('iframe', 'source'), width = this.getValueOf('iframe', 'width'), height = this.getValueOf('iframe', 'height'); var rheight = height.replace(/%/,'') * 0.01 * 7.5 + 'rem'; console.log(rheight); if(isrc != '' &amp;&amp; isrc.indexOf('http') &gt; -1)&#123; var ele = CKEDITOR.dom.element.createFromHtml( '&lt;p style="padding:5px 0;"&gt;&lt;iframe class="my-iframe" src="'+isrc+'" style="border:none;width:'+width+';height:'+rheight+';"&gt;&lt;/iframe&gt;&lt;/p&gt;' ); editor.insertElement(ele); this.commitContent(editor); &#125; &#125; &#125;;&#125; ); iframe默认是有右键菜单的，这里就暂时不注册右键事件了，以后可以优化下，如视频预览图，右键之类的功能。 另一个坑另外的一个坑是同事玩我编辑器的时候发现的：双击图片会弹出ckeditor默认的图片弹窗。而这一直是我竭力规避的情况。查了下文档，关键字doubleclick，发现这块还是写的很模糊的，搞了一圈也没发现配置选项在哪，最后没办法，只能搜源码暴力解决了。方法：在ckeditor.js内搜索’doubleclick’，可以看到它注册了很多双击事件，找到控制image的地方，直接将命令为image的代码删除，同时顺手将默认的iframe双击事件也删除，保存即可。这样双击事件就不会再触发了。方法虽然很粗暴，但是很管用。 OK，基本上到现在，我们的编辑器’看起来’还是很舒服的，基本功能都齐全，又是所见即所得的，我暂时很满意，不过不排除以后有什么新的功能需求，到时候再进行开发即可。用了两篇blog来简单说了下ckeditor的使用方法和自己的小优化，等闲下来会将自己的两个组件传到github上，方便以后查询。 下一篇估计会探讨一下plupload的用法，这个上传插件用起来还是很爽的，功能也很强大。就这样…]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>工作积累</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ckeditor自定义按钮及阿里oss上传]]></title>
    <url>%2F2017%2F08%2F22%2Fckeditor%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E9%92%AE%E5%8F%8A%E9%98%BF%E9%87%8Coss%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[啰嗦需求公司的百度编辑器已经千疮百孔了，各种bug层出不穷，因为公司图片这块的处理全是oss直传阿里的，上个前端也是费了巨力重新编辑修改了百度编辑器的图片上传功能，来贴合公司的实际需求。但是我觉得编辑器这块最重要是需要贴合用户的实际使用体验，编辑出来的页面是要在移动端展示的，最好能实现真正的“所见即所得”，傻瓜式的编辑体验，简单粗暴，够用就好，花里胡哨的功能我们也暂时用不到。参考了微信公众号编辑界面，知乎文章编辑界面，发现都是“简单”的界面实现了很“实用”的功能。接下来就是现有编辑器的选择了，毕竟自己现写个编辑器根本不现实（听说知乎的编辑器是30人的团队维护的…）。查阅了几家编辑器：wangEditor、bootstrap-wysiwyg、tinymce…感觉都对不上，不是文档太少，就是感觉“弱不经风”，官网的编辑器随手试试都能搞一两个bug出来，优化体验太差。应了知乎大神那句“编辑器是个坑，你们千万别往里跳”，一个好的编辑器真是需要精力去维护和更新的。最后选择了比较稳重的ckeditor，文档很全，支持插件，配置什么的也很友好，先给个文档链接感受一下：ckeditor在线文档https://docs.ckeditor.com/#!/guide/dev_installation。 安装配置官网下载文件，下载界面可选：Basic Package、Standard Package、Full Package、Customize。根据自己需求下载不同的安装包，而且每种都有压缩版和源码版可选。其中Customize版本顾名思义可自定义选择自己需要的模块，官方也推荐使用这种方式自定义下载，免得像我一样傻呵呵的自己下载需要的插件，结果安装依赖包安装到怀疑人生。接下来很简单，傻瓜式安装： html页面引入ckeditor.js文件，也可以使用官方CDN 12&lt;script type="text/javascript" src="ckeditor/ckeditor.js /&gt;//&lt;script src="https://cdn.ckeditor.com/4.7.2/standard/ckeditor.js"&gt;&lt;/script&gt; //官方CDN 替换textarea 1&lt;textarea name="editor1" id="editor1" rows="10" cols="80"&gt;This is my textarea to be replaced with CKEditor.&lt;/textarea&gt; 实例化ckeditor 12345&lt;script&gt; // Replace the &lt;textarea id="editor1"&gt; with a CKEditor // instance, using default configuration. CKEDITOR.replace( 'editor1' );&lt;/script&gt; 这样，一个基本可以使用的编辑器就搞好了，大概如下图： 个性化配置 ckeditor的个性化配置功能很人性化，打开下载好的ckeditor文件夹，ckeditor/samples/index.html打开，点击右上TOOLBAR CONFIGURATOR，切换到配置功能页，勾选自己需要的功能块儿，也可以调整显示顺序，上方是预览。 点击右边的Get toolbar config按钮，切换至我们配置好的config源码部分，复制该配置代码至ckeditor/config.js，直接覆盖就好。基本上所做的个性化配置都在这个文件里定义（还有另外两种配置方式，具体可以查看文档）。 123456789101112131415161718CKEDITOR.editorConfig = function( config ) &#123; config.toolbarGroups = [ &#123; name: 'document', groups: [ 'mode', 'document', 'doctools' ] &#125;, &#123; name: 'clipboard', groups: [ 'clipboard', 'undo' ] &#125;, &#123; name: 'editing', groups: [ 'find', 'selection', 'spellchecker', 'editing' ] &#125;, &#123; name: 'forms', groups: [ 'forms' ] &#125;, &#123; name: 'styles', groups: [ 'styles' ] &#125;, &#123; name: 'basicstyles', groups: [ 'basicstyles', 'cleanup' ] &#125;, &#123; name: 'colors', groups: [ 'colors' ] &#125;, &#123; name: 'paragraph', groups: [ 'list', 'indent', 'blocks', 'align', 'bidi', 'paragraph' ] &#125;, &#123; name: 'links', groups: [ 'links' ] &#125;, &#123; name: 'insert', groups: [ 'insert' ] &#125;, &#123; name: 'tools', groups: [ 'tools' ] &#125;, &#123; name: 'others', groups: [ 'others' ] &#125;, &#123; name: 'about', groups: [ 'about' ] &#125; ]; config.removeButtons = 'Image,Source,Save,NewPage,Print,Templates,PasteFromWord,PasteText,Paste,Copy,Cut,Find,Replace,SelectAll,Scayt,Form,Subscript,Superscript,CopyFormatting,Checkbox,Radio,TextField,Textarea,Select,Button,ImageButton,HiddenField,Outdent,Indent,CreateDiv,BidiLtr,BidiRtl,Language,Anchor,Table,HorizontalRule,Smiley,SpecialChar,PageBreak,ShowBlocks,Blockquote,Styles,Font,Preview,Flash,Link,Unlink,Maximize,Format,About,Iframe';&#125;; 刷新页面，就可以看到配置完的个性化编辑器了。 自定义按钮（功能）毕竟每个人的需求都是不一样的，这时候一个编辑器的“可扩展性”就必不可少了。上面说道，图片功能需要结合阿里的oss上传，policy,signature等等的验证，同时需要能有微信公众号编辑界面一样，实现图片的100%显示和原尺寸显示的自由切换。 在ckeditor/plugins文件夹下，新建一个名为oss的文件夹：内含dialogs文件夹，存放我们的弹窗内容；images文件夹，用来存放用到的小图标；plugin.js文件，定义oss插件的入口。方便起见我就用代码模拟一下，不传图了。 1234567oss...dialogs......oss.js...images......xxx.jpg......xxx.png...plugin.js 配置oss/plugin.js文件 1234567891011121314151617181920212223242526( function() &#123; CKEDITOR.plugins.add( 'oss', &#123; onLoad: function() &#123;&#125;, init: function( editor ) &#123; //上传图片插件初始化 editor.addCommand('ossupload', new CKEDITOR.dialogCommand('ossupload')); //基于dialog弹窗插件 editor.ui.addButton('oss', &#123; label: '插入图片', //鼠标hover到按钮上显示文字 icon: 'plugins/oss/images/oss.png', //自定义按钮的图标 command: 'ossupload' //点击按钮执行的命令 &#125;); // 注册右键菜单 if ( editor.contextMenu ) &#123; editor.addMenuGroup( 'oss'); editor.addMenuItem( 'image', &#123; label: '修改图片', command: 'ossupload', group: 'oss' &#125; ); &#125; CKEDITOR.dialog.add( 'ossupload', this.path + 'dialogs/oss.js' ); //弹窗文件，指向dialogs文件夹下的oss.js &#125;, afterInit: function() &#123;&#125; &#125; );&#125; )(); 接下来定义弹窗的内容，即dialogs内的oss.js文件，先看下实际效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697CKEDITOR.dialog.add( 'ossupload', function( editor ) &#123; // 图片尺寸html模板 var sizeHtml = new CKEDITOR.template( '&lt;div class="myradio"&gt;' + '&lt;div class="item" style="padding-bottom:5px;"&gt;'+ '&lt;input type="radio" name="size" value="100%" id="100" checked style="vertical-align:middle;margin:0 5px 0 0;"&gt;' + '&lt;label for="100"&gt;图片满屏显示&lt;/label&gt;'+ '&lt;/div&gt;'+ '&lt;div class="item"&gt;'+ '&lt;input type="radio" name="size" value="auto" id="auto" style="vertical-align:middle;margin:0 5px 0 0;"&gt;' + '&lt;label for="auto"&gt;图片原尺寸显示&lt;/label&gt;'+ '&lt;/div&gt;'+ '&lt;/div&gt;').output(); var currentSrc = null; //编辑时图片源地址 // 阿里oss图片上传 function plupload1() &#123; //阿里oss上传组件，使用了官网的例子，基于plupload组件 &#125;; return &#123; title: '插入图片', width: 302, //弹窗的宽px minHeight: 302, //弹窗的最小高度px,上传图片高度大于300自动撑开 contents: [ &#123; id: 'ossimage', label: '上传图片', elements: [ //自定义弹窗的内容，可以使用模板，也可自定义html及样式 &#123; id: 'myimage', //选择图片按钮 type: 'html', html: '&lt;a href="javascript:;" id="selectfile"&gt;选择图片&lt;/a&gt;', //plupload按钮 style: 'display:block;width:82px;line-height:34px;background-color:#3366b7;font-size:14px;color:#fff;text-align:center;border-radius:4px;', //html的样式，直接作用于上面的a元素 onShow: function() &#123; //当该元素show的时候执行的方法 if(currentSrc &amp;&amp; currentSrc !== 'undefined')&#123; //当右键编辑图片时执行，下篇说 $('#selectfile').hide(); $('.moxie-shim').hide(); &#125; &#125;, onLoad: function() &#123; plupload1(); //加载时实例化plupload上传组件 &#125; &#125;, &#123; type: 'html', //图片上传成功后的容器 html: '&lt;div class="container"&gt;&lt;div class="imgbox"&gt;&lt;/div&gt;&lt;a style="display:none;position:absolute;top:0;left:0;z-index:1;width:16px;height:16px;background-image:url(/assets/js/ckeditor/skins/moono-lisa/images/close2.png)"&gt;&lt;/a&gt;&lt;/div&gt;', style: 'width:300px;height:auto;position:relative;', //对应的样式 onShow: function() &#123; if(currentSrc &amp;&amp; currentSrc !== 'undefined')&#123; //右键编辑图片时，将图片src传入容器，同时注册关闭图片事件 &#125; &#125;, commit: function( editor )&#123; //点击确定按钮时，将图片src传入全局src中 src = $('.imgbox img').attr('src'); &#125; &#125;, &#123; id: 'size', //图片全屏显示及按实际尺寸显示radio type: 'html', html: sizeHtml, //html写到了上面 commit: function( editor )&#123; var tt = document.getElementsByName('size'); //取radio选项 for (var i = 0; i &lt; tt.length ; i++ )&#123; if(tt[i].checked)&#123; imgsize = tt[i].value; break; &#125; &#125; if(src != undefined)&#123; //创建element,即确定后填到编辑器中的代码，此处最好使用p标签包裹img标签，ckeditor都是使用p标签包裹元素，保持一致 var ele = CKEDITOR.dom.element.createFromHtml( '&lt;p style="padding:5px 0;"&gt;&lt;img style="max-width: 100%;width:'+imgsize+'" src="'+src+'"/&gt;&lt;/p&gt;' ); editor.insertElement(ele); //将element插入editor &#125; &#125; &#125; ] &#125; ], onShow: function() &#123; currentSrc = null; //弹窗显示的时候判断‘选中元素’的currentSrc是否存在 var element = editor.getSelection().getSelectedElement(); if(element)&#123; console.log(element); console.log(element.$.currentSrc); currentSrc = element.$.currentSrc;//源图片地址 &#125; &#125;, onOk: function () &#123; this.commitContent(editor); //点击确定时dom操作 currentSrc = null; &#125;, onCancel: function () &#123; //取消时dom操作 currentSrc = null; //取消或者确定时清空currentSrc &#125; &#125;;&#125; ); 看下上传图片后的实际效果 图片满屏显示会将图片宽度设为100%，高度自动；图片原尺寸显示会显示图片原本的尺寸。这里注意所谓图片原尺寸是指图片的实际大小，假若图片宽度200px,那么图片不管在什么设备下，宽度始终为200px，不过若是图片原尺寸超过了设备的实际宽度，那么图片的最大宽度就是设备的宽度，不会出现左右滚动条。 最后记得将我们自定义的组件注册到config.js中1config.extraPlugins = 'myiframe,oss,dialog,dialogui,lineheight,richcombo,floatpanel,panel,listblock'; //除了oss,myiframe,lineheight外，其他都为依赖组件 最后是编辑器的一些其他优化，如使用rem使编辑器宽度，字体大小等比例显示，行高组件的添加等，都是为了真正的实现所见即所得的个性化移动编辑器，真正做到了pc端编辑出来的效果就是在移动展示的实际比例效果。1234config.fontSize_defaultLabel = '12';config.fontSize_sizes='12/0.24rem;14/0.28rem;16/0.32rem;18/0.36rem;20/0.4rem;22/0.44rem;24/0.48rem;26/0.52rem;28/0.56rem;36/0.72rem;48/0.96rem;72/1.44rem';CKEDITOR.config.menu_groups = ''; //编辑器内的右键菜单设为空。搜索关键字menuitem，查看源码config.line_height = '1;1.2;1.5;2;2.2;2.5;3;3.5;4;5'; //定义行高]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>工作积累</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS随写：数据属性和访问器属性]]></title>
    <url>%2F2017%2F08%2F17%2FJS%E9%9A%8F%E5%86%99%EF%BC%9A%E6%95%B0%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7%E5%92%8C%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[今天简单来聊一聊对象的两种属性：数据属性和访问器属性 数据属性数据属性包含一个数据值的位置，有4个描述其行为的特性。 [[Configurable]] : 表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值为true。 [[Enumerable]] : 是否可枚举，表示能否通过 for-in 循环返回属性。默认值为true。 [[Writable]] : 表示能否修改属性的值。默认值为true。 [[Value]] : 包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值时，把新值保存在这个位置。默认值是 undefined。对于通过new关键字定义的对象的属性或者通过对象字面量直接在对象上定义的属性，它们的 [[Configurable]]、[[Enumerable]] 和 [[Writable]] 特性默认都被设置为 true，而 [[Value]] 特性被设置为指定的值。 Object.defineProperty( obj, prop, descriptor) obj：需要定义属性的对象 prop：需定义或修改的属性的名字。 descriptor：一个包含设置特性的描述符对象如果要修改属性默认的特性，必须使用 ECMAScript 的 Object.defineProperty() 方法。该方法接受3个参数：属性所在的对象，属性的名字和一个描述符对象。描述符对象的属性必须是：configurable、enumerable、writable和value。 1234567891011var person = &#123; name: 'liyang', age: '26'&#125;Object.defineProperty(person,'name',&#123; writable: false&#125;);console.log(person.name); //liyangperson.name = "miaomiao"; //此时，严格模式下该赋值操作会抛出错误，非严格模式下会被忽略console.log(person.name); //liyangObject.getOwnPropertyDescriptor(person,'name'); //Object &#123;value: "liyang", writable: false, enumerable: true, configurable: true&#125; 注：一旦把属性定义为不可配置的，那么就再也不能把属性定义回可配置的了。12345678910var person = &#123; name: 'liyang', age: '26'&#125;Object.defineProperty(person,'name',&#123; configurable: false&#125;);Object.defineProperty(person,'name',&#123; configurable: true&#125;); //Uncaught TypeError: Cannot redefine property: name 注：如果对一个空对象调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和writable特性默认都将是false123var person = &#123;&#125;Object.defineProperty(person,'name',&#123;value:"liyang"&#125;);Object.getOwnPropertyDescriptor(person,'name'); //Object &#123;value: "xx", writable: false, enumerable: false, configurable: false&#125; Object.getOwnPropertyDescriptor( obj, prop)该方法可以取得给定属性的描述符。接收两个参数：属性所在的对象和要读取其描述符的属性名称。如果是数据属性 ，则有configurable、enumerable、writable和value；若是访问器属性，则有configurable、enumerable、get和set; 访问器属性访问器属性不包含数据值，它们包含一对儿getter和setter函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用getter函数，在写入访问器属性时，又会调用setter函数并传入新值。 [[Configurable]] : 表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。默认值为true。 [[Enumerable]] : 是否可枚举，表示能否通过 for-in 循环返回属性。默认值为true。 [[Get]] : 在读取属性时调用的函数。默认值为 undefined。 [[Set]] : 在写入属性时调用的函数。默认值为 undefined。注：访问器属性不能直接定义，必须使用 Object.defineProperty() 来定义。123456789101112131415161718var book = &#123; _year : 2004, edition : 1&#125;;Object.defineProperty(book,"year",&#123; get : function () &#123; return this._year; &#125;, set : function (newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);console.log(book.year); // 2004book.year = 2005;console.log(book.edition); //2 getter函数返回_year的值，setter函数通过计算来得到正确的edition值。属性year的值修改为2005会导致_year的值变为2005，而edition变成2。这就是访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。getter和setter不一定非得同时指定，只指定getter意味着属性不能写，尝试写入属性会被忽略。没有指定setter属性也不能读，否则在非严格模式下会返回undefined，严格模式下抛出错误。 定义多个属性 Object.defineProperties()该方法可一次性定义多个属性。1234567891011121314151617181920var book = &#123;&#125;;Object.defineProperties(book,&#123; _year:&#123; value: 2004 &#125;, edition:&#123; value: 1 &#125;, year:&#123; get:function()&#123; return this._year; &#125;, set:function()&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;); 前几天百度编辑器bug修复之后，还是被市场同事抱怨编辑器屎一样难用。想了想决定把项目中的编辑器换掉，初步确定使用ckEditor编辑器，需要自定义一些功能：基于阿里OSS的图片上传功能和腾讯视频的iframe视频上传功能。而且编辑器编辑成文后是要在移动端展示，目标是做一个移动端的“所见即所得”编辑器，最近有得搞了。。。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>随写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度编辑器UMeditor图片缩放bug]]></title>
    <url>%2F2017%2F08%2F10%2F%E7%99%BE%E5%BA%A6%E7%BC%96%E8%BE%91%E5%99%A8UMeditor%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BEbug%2F</url>
    <content type="text"><![CDATA[今天一早公司市场部同事就找过来说项目的编辑器图片无法缩放，心想着估计又是公司上古神兽“backbone”触发什么隐藏bug了，复现了一下bug：上传到百度编辑器的图片拖曳缩放的话会无法操作，或者会有一些奇奇怪怪的问题。查看了下百度编辑器模块的config文件和组件源码，却没发现什么明显的问题。 折腾半天，审核下元素看到图片继承的属性有box-sizing:border-box，随手勾掉，发现缩放竟然正常了。百度一下“百度编辑器+bootstrap”，还真有人遇到同样问题，两者一起使用就会出现图片缩放的bug。问题定位之后，直接在UMeditor样式文件：ueditor.min.css头部添加如下样式，将box-sizing属性复原即可。12.edui-container *&#123;-webkit-box-sizing: content-box;-moz-box-sizing: content-box;box-sizing: content-box;&#125; .edui-container *:before,.edui-container *:after &#123;-webkit-box-sizing: content-box;-moz-box-sizing: content-box;box-sizing: content-box;&#125;]]></content>
      <tags>
        <tag>工作积累</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS随写：数组排序去重]]></title>
    <url>%2F2017%2F08%2F02%2FJS%E9%9A%8F%E5%86%99%EF%BC%9A%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[最近公司事情巨多，整日折腾公司的上古backbone框架，让我头疼不已，说好的最少1周1次blog的更新也多次delay，再努力吧，毕竟开头难，养成习惯也难。 数组对象按照数组中对象的某一属性大小进行排序1234567array.sort(function(a,b)&#123; //升序 if(a.id === b.id)&#123; return 0; &#125;else&#123; return a.id &lt; b.id ? -1 : 1; &#125;&#125;) 按照数组中对象的某一属性是否重复进行去重12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//使用数组的reduce方法var hash = &#123;&#125;;arr = arr.reduce(function(item, next) &#123; hash[next.name] ? '' : hash[next.name] = true &amp;&amp; item.push(next); return item&#125;, []);// 拆解var hash = &#123;&#125;;arr = arr.reduce(function(item,next)&#123; if(!hash[next.name])&#123; hash[next.name] = true; item.push(next); &#125; return item;&#125;,[]);//例子var arr = [ &#123; "name": "aaa", "age": "16" &#125;, &#123; "name": "bbb", "age": "20" &#125;, &#123; "name": "ccc", "age": "15" &#125;, &#123; "name": "bbb", "age": "30" &#125;, &#123; "name": "eee", "age": "28" &#125;];var hash = &#123;&#125;;arr = arr.reduce(function(item, next) &#123; hash[next.name] ? '' : hash[next.name] = true &amp;&amp; item.push(next); return item&#125;, []);console.log(arr);// [&#123;"name": "aaa","age": "16"&#125;,// &#123;"name": "bbb","age": "20"&#125;,// &#123;"name": "ccc","age": "15"&#125;,// &#123;"name": "eee","age": "28"&#125;,//] 纯数组排序 js自带sort排序 12345var arr = [1,8,3,4,5,9,3,6,];arr.sort(function(a,b)&#123; return a - b; //a-b升序，b-a降序&#125;);arr; //[1, 3, 3, 4, 5, 6, 8, 9] 对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以使用以上方法 –《javascript高级程序设计》 冒泡排序(选择排序？) 1234567891011121314var arr = [1,8,3,4,5,9,3,6,];function bubbleSort(arr)&#123; for(var i=0;i&lt;arr.length-1;i++)&#123; for(var j=i+1;j&lt;arr.length;j++)&#123; if(arr[i]&gt;arr[j])&#123; var temp = arr[j]; arr[j] = arr[i]; arr[i] = temp; &#125; &#125; &#125; return arr;&#125;bubbleSort(arr); // [1, 3, 3, 4, 5, 6, 8, 9] 快速排序 1234567891011121314var arr = [1,8,3,4,5,9,3,6,7];function quickSort(arr)&#123; if(arr.length &lt;= 1)&#123; //数组剩下一个不比较，直接返回，不判断的话循环无法结束 return arr; &#125; var index = Math.floor(arr.length/2); //取中间数的index var cur = arr.splice(index,1); //中间值，不能使用arr[index]替换 var left = [],right = []; //left存比中间小的，right存大的 for(var i = 0;i&lt;arr.length;i++)&#123; arr[i] &lt; cur ? left.push(arr[i]) : right.push(arr[i]); &#125; return quickSort(left).concat(cur,quickSort(right)); //递归，left和right自身多次比较排序&#125;quickSort(arr); 插入排序 1234567891011121314var arr = [8,2,3,4,5,9,3,6];function insersort(arr)&#123; for(i=1;i&lt;arr.length;i++)&#123; temp = arr[i]; j = i; while(j &gt; 0 &amp;&amp; arr[j-1] &gt; temp)&#123; arr[j] = arr[j-1]; j--; &#125; arr[j] = temp; &#125; return arr;&#125;insersort(arr); 去重1234567891011var arr = [8,2,3,4,5,4,3,6,8];function removeDup(arr)&#123; var newarr = []; for(var i = 0; i&lt;arr.length; i++)&#123; if(newarr.indexOf(arr[i]) === -1)&#123; newarr.push(arr[i]); &#125; &#125; return newarr;&#125;removeDup(arr);]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>随写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS随写：Date类型]]></title>
    <url>%2F2017%2F07%2F12%2FJS%E9%9A%8F%E5%86%99%EF%BC%9ADate%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Date要创建一个日期对象，用new操作符和Date构造函数 获取系统时间 获取当前时间：直接new Date() 根据毫秒数获取时间：传入毫秒数 创建指定时间：传入指定时间 12345678var time1 = new Date(); //获取系统当前时间time1; //Sat Jul 08 2017 14:55:09 GMT+0800 (中国标准时间)var time2 = new Date(1499496964457); //传入毫秒数获取指定时间，一般后台数据会以时间戳给你，注意时间戳是秒，不是毫秒time2; //Sat Jul 08 2017 14:56:04 GMT+0800 (中国标准时间)var time3 = new Date(2017,6,8,15,02,30); //传入指定时间来创建标准时间格式，注意月份从0开始time3; /Tue Jul 08 2017 15:02:30 GMT+0800 (中国标准时间) 以上可以使用Date类型的方法:123456789time.getTime(); // 1499496964457, 毫秒数，与valueOf()方法返回的值相同time.getFullYear(); // 2017, 年份time.getMonth(); // 6, 月份，注意月份范围是0~11，6表示七月time.getDate(); // 08, 表示8号time.getDay(); // 6, 表示星期六time.getHours(); // 15, 24小时制time.getMinutes(); // 02, 分钟time.getSeconds(); // 30, 秒time.getMilliseconds(); // 875, 毫秒数 获取时间戳 Date.parse() 接受几个指定格式的字符串参数 月/号/年； 例如：7/8/2017 英文月 号,年; 例如：July 8,2017 标准格式； 例如：Tue Jul 08 2017 15:02:30 GMT+0800 ECMA5支持格式YYYY-MM-DDTHH:mm:ss.sssZ； 例如：2017-07-08T15:02:30 1234var d = Date.parse('7/8/2017'); //毫秒数1499443200000var d = Date.parse('July 8,2017'); //毫秒数1499443200000var d = Date.parse('Tue Jul 08 2017 15:02:30 GMT+0800'); //毫秒数1499497350000var d = Date.parse('2017-07-08T15:02:30'); //毫秒数1499497350000 Date.UTC() 直接接受参数(年,基于0的月,日,时,分,秒,毫秒) 123var d = Date.UTC(2017,7,8,15,02,30); //毫秒数 1502204543000//注意，时间戳是基于1970年1月1日凌晨，全世界都一样，只是转化成本地时间会有时区差别var time = new Date(1502204543000); //Tue Aug 08 2017 23:02:23 GMT+0800 (中国标准时间) 调用时的当前时间ECMAScript 5新增 Date.now()方法，返回调用这个方法时的日期和时间的毫秒数 1234var start = Date.now(); //取得开始时间dosomething(); //调用函数var end = Date.now(); //取得结束时间var result = end - start; //毫秒数 杂七杂八 若直接将表示日期的字符串传给Date构造函数也会在后台调用Date.parse()进行转换。 12var time = new Date('7/8/2017'); //等同于new Date(Date.parse('7/8/2017'));time; // Sat Jul 08 2017 00:00:00 GMT+0800 (中国标准时间) 上面的 var time3 = new Date(2017,6,8,15,02,30) 同理使用了Date.UTC()转化]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>随写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS随写：Array数组]]></title>
    <url>%2F2017%2F07%2F02%2FJS%E9%9A%8F%E5%86%99%EF%BC%9AArray%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[创建数组的两种方式：1.使用Array构造函数 var colors = new Array() , new 操作符可省略给构造函数传递一个值的话，若为数值，则该值为新数组的长度；若为其他类型，则该值为新数组的第一个元素，且数组长度为1。12var colors = new Array(3); //创建一个包含3项的数组，值都为undefinedvar colors = new Array("liyang"); //创建一个包含1项，即字符串'liyang'的数组 根据此特性创建一个重复某字符串n次的方法：12345function repeatString(str,n)&#123; return new Array(n+1).join(str); //创建一个长度为n+1的空数组，使用str来连接这个空数组的元素,即undefined&#125;repeatString("a",4); // 返回 "aaaa"repeatString("3",3); //返回 "333" 2.使用数组字面量表示法123var colors = ['red','yellow','green'];var values = [1,2,]; //不推荐，IE8及以下会视为长度为3，最后一个值为undefinedvar options = [,,,]; //不推荐，IE8会视为长度为4，值都是undefined 直接给Array的length赋一个新的值会导致Array大小的变化;Array可以通过索引把对应的元素修改为新的值;如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化 检测数组 value instanceof Array 执行环境会对其判断有影响 ECMAScript5新增的方法 Array.isArray() 来确定某个值到底是不是数组 转换方法所有对象都有 toLocaleString()、toString()和valueOf()方法，数组的调用如下： toString():返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的 字符串； toLocaleString():同样返回一个逗号分隔的字符串，不同在于会调用数组每一项的toLocaleString()方法，而不是toString()方法； valueOf(): 返回数组； shift,unshift和push,pop shift() 方法删除 Array 的第一个元素，返回的是删掉的元素 unshift() 方法向 Array 的头部添加若干值，返回的是新数组的长度 push() 方法向 Array 的尾部添加若干值，返回的是新数组的长度 pop() 方法删除 Array 的最后一个元素，返回的是删掉的元素 12345678910var arr = [1,2,3,4];arr.shift(); // 返回'1'arr; // [2,3,4]arr.unshift('a','b'); //返回 5arr; //['a','b','2','3','4']arr.push('c','d'); //返回 7arr; //['a','b','2','3','4','c','d']arr.pop(); //返回 'd'arr; //['a','b','2','3','4','c'] reverse和sort reverse() 方法用于反转数组项的顺序 sort() 方法用于排序数组，默认按照升序排序sort() 方法会调用每个数组项的 toString() 方法，然后比较字符串进行排序，可以接受一个比较函数作为参数。 123456789101112var arr = [13,15,5,2,6];arr.sort();arr; //[13,15,2,5,6]arr.sort(function(a,b)&#123; return a - b; //升序&#125;);arr; //[2,5,6,13,15]arr.sort(function(a,b)&#123; return b - a; //降序&#125;);arr; //[15,13,6,5,2] slice和splice slice() 方法截取数组的部分元素，根据索引来截取。对应字符串的 substring() 方法 splice() 方法可以从指定的索引处开始删除n个元素，然后再从该位置添加m个元素，是数组的万能方法 1234567891011121314151617181920212223242526var arr = ['red','yellow','green','blue'];arr.slice(1,3); //从1开始截取到3，不包括3。返回截取的数组['yellow','green']arr; //数组本身不变：['red','yellow','green','blue']var arr2 = ['red','yellow','green','blue'];arr2.slice(2); //从索引2开始到结束。['green','blue']arr2; //数组本身不变：['red','yellow','green','blue']var arr3 = ['red','yellow','green','blue'];var copy = arr3.slice(); //不传值相当于复制数组copy; //返回：['red','yellow','green','blue']copy === arr; // falsevar arr4 = ['red','yellow','green','blue'];arr4.slice(1,-1); // ['yellow','green'] -1索引指最后一个元素，-2指倒数第二个---------------var arr1 = ['a','b','c','d'];//从索引2开始删除1个元素，然后再添加两个元素arr1.splice(2,1,'red','yellow'); //返回删除的元素['c']arr1; // ['a','b','red','yellow','d']//只删除，不添加arr1.splice(1,2); //返回删除的元素数组 ['b','red']arr1; // ['a','yellow','d']//只添加，不删除arr1.splice(1,0,'green'); //返回空[],因为没有删除元素arr1; // ['a','green','yellow','d'] 注意是在索引1的&lt;前面&gt;添加新元素 concat和join concat() 方法把当前的Array和另一个Array连接起来，返回一个新的数组 join() 方法把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串 123456789101112var arr = ['a','b','c'];var added = arr.concat([1,2,3]);added; // ['a','b','c',1,2,3]arr; //['a','b','c'] 原数组并未改变arr.concat([1,2],3); // ['a','b','c',1,2,3] 数组元素会被拉平arr.concat([1,2,[3,4]]); // ['a','b','c',1,2,[3,4]] 多重数组不会被拉平var arr2 = ['a','b','c',1,3]arr.join('-'); //返回字符串 a-b-c-1-3arr; //['a','b','c',1,3] 原数组并未改变arr.toString(); //返回字符串 a,b,c,1,3arr.join(','); //返回字符串 a,b,c,1,3 同toString()方法 indexOf和lastIndexOf两者都接收两个参数：要查找的项和表示查找地点的索引（可选）；indexOf()从数组开头开始向后查找，lastIndexOf()从数组的末尾向前查找。若查找的项没找到则返回-1123456789var arr = [1,2,3,2,1];arr.indexOf(2); //1arr.indexOf(99); //-1arr.indexOf(1,1); //4arr.indexOf(1,-3); //4arr.indexOf(2,-1); //-1arr.lastIndexOf(2); //3arr.lastIndexOf(2,-2) //3arr.lastIndexOf(2,-3) //1 数组的迭代方法ECMAScript5定义了5个数组的迭代方法,每个方法都接收2个参数：要在每一项上运行的函数和运行该函数的作用域对象-影响this的值（可选）。 函数会接收3个参数：数组项的值item，item项的索引index和该数组对象本身。 every()和some()every() ：数组中每一项运行函数，都返回true，才返回true。some() ：数组中每一项运行函数，有一项返回true，就返回true。 filter()数组中每一项运行函数，返回 函数运行为true的项 组成的数组。 map()数组中每一项运行函数，返回 每次调用函数返回的值 组成的数组，跟原数组一一对应。 forEach()对数组中每一项运行函数，没有返回值 数组的归并方法reduce()和reduceRight()ECMAScript5定义了2个数组的归并方法，每个方法都接收2个参数：在每一项调用的值和作为归并的初始值（可选）。 函数会接收4个参数：前一个值，当前值，项的索引和数组对象本身。这个函数的返回值会作为第一个参数自动传个下一项。 第一次迭代发生在数组第二项上，因此第一个参数是数组第一项，第二个参数是数组第二项。12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev,cur,index,array)&#123; return prev + cur;&#125;);sum; // 15 第一次执行回调函数，prev是1，cur是2。第二次执行，prev是返回值3，cur是第三项3。过程直至数组最后一项。12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev,cur,index,array)&#123; return prev + cur;&#125;,6);sum; // 21 若传入第二个参数作为初始值（可为任意值），则第一次prev是6，cur是数组第一项1。reduceRight()是反过来从最后开始执行。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>随写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS随写：原型及原型链]]></title>
    <url>%2F2017%2F06%2F25%2FJS%E9%9A%8F%E5%86%99%EF%BC%9A%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型链这个话题算是老生常谈了，随意一搜，网上大把文章来论述这个话题。 知识准备先给个经典的person构造函数： 1234567891011function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; console.log(this.name); &#125;;&#125;var person1 = new Person("liyang", 26, "programmer");var person2 = new Person("xiaoming", 24, "designer"); 在js中，万物皆对象，原型Person.prototype也是对象。 理解构造函数、实例和原型的概念。 构造函数: 构造函数其实就是函数，但任何函数如果使用 new 操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样。按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该使用一个小写字母开头。 123456789101112// 当作构造函数使用var person = new Person("liyang", 26, "programmer");person.sayName(); // "liyang"// 作为普通函数调用Person("xiaoming", 24, "designer"); // 添加到 windowwindow.sayName(); // "xiaoming"// 在另一个对象的作用域中调用var o = new Object();Person.call(o, "Tommy", 3, "Baby");o.sayName(); // "Tommy" 实例：使用 new 操作符来创建Person的新实例 person1 和 person2 。 12var person1 = new Person("liyang", 26, "programmer");var person2 = new Person("xiaoming", 24, "designer"); 原型: 简单来说， Person.prototype 就是Person原型。注意，原型也是对象，且所有函数的默认原型都是Object的实例，所以 Person.prototype 同时也是Object的一个实例。 理解原型对象函数一创建，就会按照一组特定的规则（暂时搞不清）来给这个函数创建一个 prototype 属性，其实就是函数 Person() 创建了，它的原型 Person.prototype 就有了。我们再来new一个Person的实例 person1：1var person1 = new Person("liyang", 26, "programmer"); 实例person1的内部会包含一个官方ECMA5称为 [[Prototype]] ，Firefox、Safari和Chrome称为 __proto__ 的指针，而这个指针 __proto__ 就会指向构造函数的原型对象 Person.prototype ，注意：这个指向是存在于实例 person1 和 原型对象 Person.prototype 之间的，跟构造函数 Person() 是没半毛钱关系的。 扩展一下：实例 person1 有一个 __proto__ 的指针指向了原型对象 Person.prototype ，前面说过原型也是个实例，那它同样也会有个 __proto__ 的指针，指向了谁呢？指向了 Object.prototype 这个原型。最后 Object.prototype 原型的 __proto__ 指向了原型链的终点 null 。 网上盗图一波： why原型?为什么要用原型？因为使用原型可以让所有对象的实例共享它所包含的属性和方法，先来个代码：12345678910111213141516function Person()&#123;&#125;Person.prototype.name = "xiaohong";Person.prototype.age = 25;Person.prototype.job = "teacher";Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();person1.sayName(); // "xiaohong"var person2 = new Person();person2.sayName(); // "xiaohong"console.log(person1.sayName == person2.sayName); // true 当调用 person1.sayName() 的时候，解析器会先在person1里找，找不到的话就接着在上面的 Person.prototype 里找，找到就返回，找不到就接着往上，在 Object.prototype 里面找，这样一级一级的找下去。 杂七杂八 Person.prototype.construtor === Person; //ture 使用 hasOwnProperty() 检测一个属性是存在于实例中，还是存在于原型中。 12Person.name = "xiaohong"; //ture name属性可访问到Person.hasOwnProperty("name"); //false name属性不在实例中 实例重新定义属性会屏蔽原型属性，可使用 delete 操作符删除实例属性，但不可删除原型上的属性。若以对象字面量的方式来封装原型的功能，那么就相当于重写了整个原型对象，constructor属性指向将会改变，可以通过属性设置将constructor属性重新指向，此时constructor属性将会[[Enumerable]]可枚举（默认原生constructor不可枚举）。 12345678910111213function Person()&#123;&#125;;var person1 = new Person(); //重写原型对象之前实例化Person.prototype = &#123; construtor: Person, //重新指向Person name: 'xiaowang', age:'30', sayName: function()&#123; alert(this.name); &#125;&#125;;var person2 = new Person(); //重写原型对象之后实例化console.log(person1.name); //undefinedconsole.log(person2.name); //xiaowang 若如上重写原型对象，会切断现有原型与任何之前已经存在的对象实例之间的联系，所以必须在其之后再创建实例。 让原型对象等于另一个类型的实例，来实现原型链的继承。1son.prototype = new Father(); //将son的原型作为Father()的实例]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>随写</tag>
      </tags>
  </entry>
</search>
